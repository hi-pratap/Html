# Java Interviews Hub

Owner: Pratap Adhav

1. [Java Basics](Java%20Interviews%20Hub%20e24e46c5787342739714f984a63cb120.md)
2. [Opps Concept in Java](Java%20Interviews%20Hub%20e24e46c5787342739714f984a63cb120.md)
3. [Exception Handling in Java](Java%20Interviews%20Hub%20e24e46c5787342739714f984a63cb120.md)
4. [Collections in Java](Java%20Interviews%20Hub%20e24e46c5787342739714f984a63cb120.md)
5. 

# ***1. Java Basic Concepts:***

## 1.1. ***Java Compiler:***

Process of converting source code into a machine-independent encoding, known as Byte code with the help of JVM is known as Java Compiler. Main aim of java compiler is to check the synthetically error.

![Untitled](Java%20Interviews%20Hub%20e24e46c5787342739714f984a63cb120/Untitled.png)

## 1.2. ***Java Interpreter:***

Process of converting Byte code into native code is call as java Interpreter.

![Untitled](Java%20Interviews%20Hub%20e24e46c5787342739714f984a63cb120/Untitled%201.png)

---

## 1.3. ***JVM (Java Virtual Machine):***

it doesn't physically exist. It is a specification that provides a runtime environment in which Java byte code can be executed. It can also run those programs which are written in other languages and compiled to Java byte code.

The JVM performs following operation:

- Loads code
- Verifies code
- Executes code
- Provides runtime environment

![Untitled](Java%20Interviews%20Hub%20e24e46c5787342739714f984a63cb120/Untitled%202.png)

## 1.4. ***JDK:***

JDK is stands Java Development Kit. The Java Development Kit (JDK) is a software development environment which is used to develop Java applications . It physically exists.

## 1.5. ***JRE:***

JRE stands for Java Runtime Environment. The Java Runtime Environment is a set of software tools which are used for developing Java applications. It is used to provide the runtime environment.

## 1.6. ***Operators in Java***

1. increment & decrement operators
2. string concatenation operators
3. arithmetic operators
4. Logical operators.
5. Relational operators
6. assignment operator
7. Bitwise operators
8. Ternary operator
9. Shift operator
10. (.) operator
11. New instance operator

### 1.6.1. ***Ternary operators***

It includes three operands. Java Ternary operator is used as one-line replacement for if-then-else statement and used a lot in Java programming. It is the only conditional operator which takes three operands.

### 1.6.2. **Bitwise AND(&) operators-**

The bitwise & operator always checks both conditions whether first condition is true or false.

```java
public static void main(String[] args) {

int x=20;

int y=10;

System.out.println(x<y & x>y) ;//false && true = false

System.out.println(x>y & y<x);//true && true = true

System.out.println(x>y & y>x);//true && false = false

System.out.println(x<y & y>x);// false && false = false

}

}
```

### 1.6.3. **Bitwise OR(|) operators-**

The bitwise (|) operator always checks both conditions whether first condition is true or false.

```java
public static void main(String[] args) {
		int x=20; 
		int y=10; 
System.out.println(x<y|x>y) ;//false && true = true
System.out.println(x>y | y<x);//true && true = true  
System.out.println(x>y | y>x);//true && false = true
System.out.println(x<y | y>x);// false && false = false 

}
}
```

### 1.6.4. ***Logical AND (&&) operators**-*

Logical && operator doesn't check second condition if first condition is false. It checks second condition only if first one is true.

```java
public static void main(String[] args) {
		int x=20; 
		int y=10; 
System.out.println(x<y&&x>y) ;//false && true = false  
System.out.println(x>y &&y<x);//true && true = true  
System.out.println(x>y &&y>x);//true && false = false 
System.out.println(x<y &&y>x);// false && false = false 

}
}
```

### 1.6.4. ***Logical OR (||) operators-***

Logical || operator doesn't check second condition if first condition is true. It checks second condition only if first one is false.

```java
public static void main(String[] args) {
		int x=20; 
		int y=10; 
System.out.println(x<y||x>y) ;//false && true = true
System.out.println(x>y || y<x);//true && true = true  
System.out.println(x>y || y>x);//true && false = true
System.out.println(x<y || y>x);// false && false = false 

}
}
```

## 1.7. Loops In Java:

## 1.7.1. *For loop*

f the number of iterations is **fixed**, it is recommended to use for loop.

```java
for (initialization; condition; increment/decrement) {    
//statement   
}
```

## 1.7.2. While Loop

If the number of iterations is not fixed, it is recommended to use the while loop. The Condition argument should be of Boolean type. Otherwise we will get a compile time error. While loop is just like the for loop, we separately need to initialize and increment the variable used in the condition

```java
int i=1;  
		    while(i<=5) {  
		        System.out.println(i);  
		    i++;  
		    }  
		

```

## 1.7.3. Do-While Loop

If the number of iterations is not fixed and you must have to execute the loop at least once, it is recommended to use a do-while loop.

```java
do {    
//statement  
//increment/decrement  
} while (condition);
```

## 1.7.4. ***Continue Statement:***

*continue statement* is used to continue the loop. It continues the current flow of the program and skips the remaining code at the specified condition.

```java
//Q. Print all even number between 1 to 10.
for (int i=1; i<=10; i++) {
			if (i%2! =0)
			continue;
			System.out.println(i);
		}

Output:
2
4
6
8
10
```

## *Access specifiers:*

### Public:

1. If a class declared as public then we can access that class from anywhere. Within the package or outside the package.
2. It applies to outer class, inner class, global variables, static variables, methods and constructors.
3. Local variables can’t be public because they have a limited scope

*`Example`*

We declared the class as public in example. package1 let access the class in outside the package i.e. example. package2

```java
package com.example.package1;

public class Test {

	
	public void methodOne(){
	System.out.println("test class method one is executed");
	}
	}

package com.velocity.Pacakge2;

import com.example.package1.Test;

public class Test1 {
	public static void main(String[] args) {
		Test test= new Test();
		test.methodOne();
	}
	
}
```

*Output*

test class method one is executed

### Protected:

- If a member declared as the protected then we can access that member within the current package anywhere but outside package only in child classes.
- But from outside package we can access protected members only in child classes and should be by child reference only that is we can't use parent reference to call protected members from outside package.
- If you do not make the child class, it cannot be accessed from outside the package.
- It applies to global variables, static variables, methods, constructors, inner class and outer class

If I make the method with protected access specifier in package1 (**package** com. example. package1) when I try to access outside the package it’s not accessible it gives the compile error.

### Private:

- If a member declared as the private then we can access that member only with in the current class.
- Private methods are not visible in child classes
- *It cannot be accessed from outside the class*
- *It applies to global variables, static variables, methods, constructors and inner class*
- Local variable can’t be private.

`private then we can access that member only with in the current class.`

### Default:

- *If a class declared as the default then we can access that class only within the current package hence default access is also known as "package level access".*
- If you don't use any modifier, it is treated as **default** by default. The default modifier is accessible only within package. It cannot be accessed from outside the package.

It applies to global variables, static variables, methods, constructors and inner class.

---

## Static Keyword

1. The static keyword in Java is **used for memory management, sharing variables and methods, and accessing class members without creating an object**
2. Static variables are shared among all instances of a class, while non static variables are specific to that instance of a class. 
3. Static variable is like a **global variable** and is available to all methods.
4.  Non static variable is like a local variable and they can be accessed through only instance of a class.
**Static blocks are called before the main function.**
Static methods are used when you need to access a class member without creating an object.

### 1. Static Variable:

A static variable in Java is **a variable that belongs to the class itself rather than to any specific instance of the class**. This means that there is only one copy of the variable in memory, regardless of how many instances of the class are created.

Static variables are declared with the **`static`** keyword. For example:

```java
public class StaticVariable {  
static int count;  
public static void main(String[] args) {    
count = 10;    
System.out.println(count); *// 10*  
}
}
```

In this example, the **`count`** variable is declared static. This means that there is only one copy of the variable, which is shared by all instances of the **`StaticVariable`** class.

When the **`main()`** method is executed, the **`count`** variable is initialized to 10. This value is then printed to the console.

Since the **`count`** variable is static, it can be accessed from any instance of the **`StaticVariable`** class. For example:

```
public class StaticVariable {

  static int count;

  public static void main(String[] args) {
    count = 10;
    System.out.println(count);// 10
  }

  public void printCount() {
    System.out.println(count);// 10
  }

}
```

In this example, the **`printCount()`** method prints the value of the **`count`** variable. Since the **`count`** variable is static, it can be accessed from the **`printCount()`** method, even though the **`printCount()`** method is not static.

Static variables can be used to **store data** that is shared by all instances of a class. For example, a static variable could be used to store the number of objects that have been created.

Static variables can also be used to access resources that are shared by all instances of a class. For example, a static variable could be used to access a database connection.

---

### 2. Static Methods:

A static method in Java is a method that is declared using the **`static`** keyword. Static methods belong to a class, not an object, and **they can be called without creating an object of the class.** Static methods are often u**sed for utility classes and singletons.**

To declare a static method, use the **`static`** keyword before the method name. For example:

```java
public static void main(String[] args) {
  System.out.println("Hello, World!");
}
```

This method is static because it is declared with the **`static`** keyword. It is also the main method, which is the entry point for all Java programs.

Static methods can be accessed without creating an object of the class. For example:

```java
System.out.println("Hello, World!");
```

This will print the string "Hello, World!" to the console.

Static methods can also be accessed from other static methods. For example:

```java
public static void printHello() {
  System.out.println("Hello!");
}

public static void main(String[] args) {
  printHello();
}
```

This will print the string "Hello!" to the console.

Static methods should be used sparingly and only when it makes sense. In general, it is usually better to create an object of the class and call instance methods on that object

---

### 3. Static Block:

1. A static block in Java is **a block of code that is executed only once when the class is first loaded into memory**. It's typically used for initializing static variables, and it can also be used to perform any one-time computations or setup operations.
2. Static blocks are executed before the main() method, and they can be used to initialize any static variables that are used in the class. Static variables are variables that are shared by all instances of a class, and they are typically used to store data that is common to all instances of the class.

`For example, the following code shows a static block that is used to initialize a static variable:`

```java
public class StaticBlock {

  static int count;

  static {
    count = 0;
  }

  public static void main(String[] args) {
    System.out.println(count);
  }
}
```

1. In this example, the static block is used to initialize the static variable **`count`** to 0. The static block is executed only once, when the class is first loaded into memory. After the static block is executed, the main() method is called. In the main() method, the value of the static variable **`count`** is printed to the console.
2. Static blocks can be used to perform any one-time computations or setup operations that need to be performed when the class is first loaded into memory. For example, the following code shows a static block that is used to create a database connection:

```java
public class StaticBlock {

  static Connection connection;

  static {
    try {
      connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/database", "user", "password");
    } catch (SQLException e) {
      e.printStackTrace();
    }
  }

  public static void main(String[] args) {
    System.out.println(connection);
  }
}
```

In this example, the static block is used to create a database connection. The database connection is then used in the main() method.

Static blocks are a powerful tool that can be used to initialize static variables and perform any one-time computations or setup operations. However, it is important to use static blocks sparingly, as they can make the code more difficult to understand and maintain.

---

## Inner Classes:

In Java, inner class refers to the class that is declared inside class or interface

**There are certain advantages associated with inner classes are as follows:**

- Making code clean and readable.
- Private methods of the outer class can be accessed, so bringing a new dimension and making it closer to the real world.

---

## Anonymous classes:

1. An anonymous class in Java is **a class that does not have a name**. 
2. It is created and instantiated in a single line of code. 
3. Anonymous classes are often used when you want to create a class that is only used once.

For example, the following code creates an anonymous class that implements the Runnable interface:

```java
new Runnable() {
  public void run() {
    System.out.println("Hello, world!");
  }
};
```

This anonymous class has a single method, **`run()`**, which prints the string "Hello, world!" to the console.

1. Anonymous classes can also be used to extend classes. 

For example, the following code creates an anonymous class that extends the Thread class:

```java
new Thread() {
  public void run() {
    System.out.println("Hello, world!");
  }
}.start();
```

This anonymous class has a single method, **`run()`**, which prints the string "Hello, world!" to the console. It also has a constructor, which is used to create the object.

1. Anonymous classes are a useful tool for creating small, simple classes that are only used once. 
2. They can also be used to extend classes and implement interfaces.

---

## Constructor

1. In Java, a constructor is **a special type of method that is used to initialize an object**. 
2. It is called when an instance of an object is created and memory is allocated for the object. 
3. The constructor is a special member function of a class with the same name as the class name but has no return type.
4. constructor cannot be abstract, static, final.

**There are three types of constructors in Java:**

- **No-Arg Constructor**: This constructor does not have any parameters.
- **Parameterized Constructor**: This constructor has parameters.
- **Default Constructor**: This constructor is the default constructor and it has no parameters.

`The following is an example of a Java constructor:`

```java
public class Main {
  int x;
  public Main() {
    x = 5;
  }
  public static void main(String[] args) {
    Main myObj = new Main();
    System.out.println(myObj.x);
  }
}
```

In this example, the **`Main`** class has a constructor that takes no parameters. The constructor initializes the **`x`** variable to 5. The **`main()`** method creates a new instance of the **`Main`** class and prints the value of the **`x`** variable.

You can also use constructors to initialize other variables in your class. For example, the following code creates a constructor that takes two parameters:

```java
public class Main {
  int x;
  int y;
  public Main(int x, int y) {
    this.x = x;
    this.y = y;
  }
  public static void main(String[] args) {
    Main myObj = new Main(5, 10);
    System.out.println(myObj.x + " " + myObj.y);
  }
}
```

In this example, the **`Main`** class has a constructor that takes two parameters, **`x`** and **`y`**. The constructor initializes the **`x`** and **`y`** variables to the values of the parameters. The **`main()`** method creates a new instance of the **`Main`** class with the values 5 and 10 for the **`x`** and **`y`** parameters. The **`main()`** method then prints the values of the **`x`** and **`y`** variables.

Constructors are important because they allow you to initialize the variables of your class when you create an instance of the class. This makes it easier to use your class and ensures that your variables are always initialized to the correct values.

# 2. OOPS Concept in Java:

The main aim of object-oriented programming is to implement real-world entities, for example, object, classes, abstraction, inheritance, polymorphism, etc.

OOP stands for Object-Oriented Programming**.**

It include class,object,[abstraction](https://stackify.com/oop-concept-abstraction/), [encapsulation](https://stackify.com/oop-concept-for-beginners-what-is-encapsulation/), [inheritance](https://stackify.com/oop-concept-inheritance/) and [polymorphism](https://stackify.com/oop-concept-polymorphism/) we can say that these are the four pillar of oops.

## Object

 Any entity that has state and behavior is known as an object. For example, a chair, pen, table, keyboard, bike, etc. It can be physical or logical.

**Example:** A dog is an object because it has states like color, name, breed, etc. as well as behaviors like wagging the tail, barking, eating, etc.

---

## **Class**

*Collection of objects* is called class. It is a logical entity.

A class can also be defined as a blueprint from which you can create an individual object. Class doesn't consume any space.

---

## *Encapsulation*

Binding of data and corresponding methods into a single unit is called Encapsulation.

## Inheritance

*When one object acquires all the properties and behaviors of a parent object*, it is known as inheritance. It provides code reusability. **It is used to achieve runtime polymorphism.**

Whatever property having to parent class by default available to child class that means the process of creating the new class by using the existing class functionality called as Inheritance.

- It is called as - (IS-A Relationship)
- The main advantage of IS-A relationship is reusability
- By using "**extends**" keywords we can implement IS-A relationship.

***Point to be remember:***

1. Whatever the parent has by default available to the child but whatever the child has by default not available to the parent. Hence on the child reference we can call both parent and child class methods. But on the parent reference we can call only methods available in the parent class and we can't call child specific methods.
2. Parent class reference can be used to hold child class object but by using that reference we can call only methods available in parent class and child specific methods we can't call.
3. **Child class reference cannot be used to hold parent class object.**
4. Inherit the classes by using **extends** keywords.
5. Why we use inheritance that is for code **reusability**, reusability means **we can reuse existing class features such as variables and method, etc.**
6. We cannot extend the final class.

### **Dynamic dispatch-**

1. Dynamic method dispatch in Java is **the process by which a call to an overridden method is resolved at runtime**. This is how Java implements runtime polymorphism. 
2. When an overridden method is called by a reference, Java determines which version of that method to execute based on the type of object that the reference refers to.

For example, if you have a class **`Animal`** with a method **`speak()`**, and you have a subclass **`Dog`** that overrides the **`speak()`** method, then the following code will print "Woof":

```
Animal animal = new Dog();
animal.speak();
```

1. At runtime, the JVM will determine that the **`speak()`** method on the **`Dog`** object should be called, even though the reference to the object is of type **`Animal`**.

Dynamic method dispatch is possible because of the way that Java objects are stored in memory. Each object has a table of virtual methods, which is a list of all the methods that can be called on that object. When a method is called, the JVM looks up the method in the object's virtual method table and then calls the appropriate method.

Dynamic method dispatch is a powerful feature that allows for a lot of flexibility in Java programming. It allows you to write code that is more general and reusable, and it makes it easier to add new features to your code without having to change existing code.

### Types of Inheritace:

1. Single inheritance
2. Multilevel inheritance
3. Hierarchical inheritance
4. Multiple inheritance
5. Hybrid inheritance

### 1*.Single/Simple Inheritance*

In this only one super/parent class and only one sub class/child called as single/simple Inheritance. 

### *2.Multilevel inheritance*

It has only one base class and number of derived class called as multilevel. Or it refers to the concept of one class extending (Or inherits) more than one base class.

### *3. multiple inheritance*

Having more than one Parent class at the same level is called multiple inheritance.

### *4.Hierarchical inheritance*

One class is inherited by many sub classes called as.

### 5*.Hybrid inheritance*

It is the combination of single and multiple inheritance. So, it is not allowed in java.

## *Polymorphism*

One entity that behaves differently in different cases called as polymorphism.

Polymorphism in Java is **the phenomenon by which an object can acquire the ability to operate from different perspectives**.

**If *one task is performed in different ways*, it is known as polymorphism.** 

In Java, we use method overloading and method overriding to achieve polymorphism.

**Example**-

1. Light button, we are using that button to on or off the lights.
2. a person acts as an employee in the office, a customer in the shopping mall, a passenger in bus/train, a student in school, and a son at home.
3. Smartphone is entity that behaves different such as text message, calling, send mail, video call etc.

### **How to achieve polymorphism in java?**

We can achieve polymorphism by using two ways.

1. Method overloading-
2. Method overriding-

### Method overloading-

**It is the same method name with different argument called as Method overloading. There is no need of super and sub class relationship.**

It is called as **early binding**, compile time polymorphism or static binding.

**Rules-**

- Method name must be same.
- Parameter or argument must be different.
- Return type is anything
- Access specifier is anything

```java

package com.tests;

public class TestMain {

	void add(int a, int b) {
		System.out.println(a + b);

	}

	void add(double a, double b) {
		System.out.println(a + b);
	}

	void add(double a) {
		System.out.println(a);
	}

	void add(int a, int b, int c) {
		System.out.println(a + b + c);
	}
}

package com.tests;

public class ExampleMain {

	public static void main(String[] args) {

		TestMain testmain = new TestMain();
		testmain.add(10.5);
		testmain.add(10.5, 11.5);
		testmain.add(2, 4);
		testmain.add(5, 10, 15);
	}
}

Output is

10.5
22.0
6
30
```

### **Method overriding-**

1. **It is the same method name with same argument called as method overriding.**
2. There is need of super and sub relationship.
3. It is called as late binding, run time polymorphism or dynamic binding. Dynamic Method dispatch etc.

**Rules-**

- Method name must be same.
- Return type must be same or different.
- Access specifier is anything.
- Parameters must be same.

Note- we can extend the method scope in overriding but not reduce the visibility of it.

| superclass | In subclass, we can have access specifier |
| --- | --- |
| public | Public |
| protected | protected, public |
| default | default, protected, public |
| private | We cannot override the private |

## *Abstraction*

*Hiding internal details and showing functionality* is known as abstraction. For example phone call, we don't know the internal processing.

It is the process of hiding the certain details and showing the important information to the end user called as “Abstraction”.

Example- Real life scenario is car.

How to achieve the Abstraction in java?

There are two ways to achieve the abstraction in java.

1. Abstract class
2. Interface

### *Abstract class:*

- Abstract class have constructor
- It contains abstract methods or concrete methods or empty class or combination of both methods.
- To use abstract method of class, we should extends the abstract class and use that methods.
- If we don't want to implement or override that method, make those methods as abstract.
- If any method is abstract in a class then that class must be declared as abstract
- We cannot create the object of abstract class.

Note- Multiple inheritances are not allowed in abstract class but allowed in interfaces

### *Interface :-*

1. It contains public abstract methods and public static final variables by default.
2. We must follow I to C design principle in java. It means every class must be implemented by some interfaces.
3. In company, Team Lead or Manager level people can design the interface then give it to developer for implementing it.

5. Before 1.7, interface does not have any method body.

6. 1.8 Declare the default & static method with body in interface.

7. 1.9 we can define the private methods in interface also.

8. We cannot create the object of interface.

9. In interface, we can just define the method only but implemented that methods into implemented class.

10. Java supports multiple inheritance in the terms of interfaces but not classes.

11. Interface does not have constructor.

<aside>
💡 Below is the list of possible scenarios regarding the interface and

**Note- Try this from your end on laptop or desktop.**

- interface can extend interface1 and interface2
- Interface can extends interface
- Interface can extends the multiple interface
- class extends class implements interface
- class implements interface
- class extends class implements interface1 and interface2
</aside>

## *Wrapper class*🥇

provides the mechanism to convert primitive’s data type into object and object into primitive’s data type called as wrapper class.

Process of converting primitive’s data type into object called as “Autoboxing.”  And process of converting object into primitive’s data type called as “Unboxing.”

- **There are 8 classes of java.lang.package are known as wrapper classes in java.**
    1. Integer
    2. Short
    3. Byte
    4. Long
    5. Double
    6. Character
    7. Boolean
    8. Float

```java
int a = 20; // primitive data type

		Integer i = new Integer(a); // autoboxing
		System.out.println("i>>" + i);

		int b = i.intValue();   //unboxing 
		System.out.println("b>>"+b);

```

## Object Class🈴

- As object class acts as a root (or) parent (or) super for all java classes, by default its methods are available to every java class.
- If our class doesn't extends any other class then it is the direct child class of object If our class extends any other class then it is the indirect child class of Object
- For writing any java program the most commonly required classes and interfaces are encapsulated in the separate package which is nothing but java.lang package.
- It is not required to import java.lang package in our program because it is available by default to every java program
- **The following is the list of all methods present in java.lang Object class :**
    
    **1.  toString();**
    
    > It returns the string representation of this object.
    > 
    > 
    > Whenever we are try to print any object reference internally toString() method  will be executed.
    > 
    
    **2. hashCode();**
    
    > For every object unique number is generated by JVM called as `hashcode`. It is based on address of the object but it doesn't mean hashCode represents address of the object. Jvm will be using hashCode while saving objects into hashing related data structures like HashSet, HashMap, and Hashtable etc.
    > 
    > 
    > ## **Note-**
    > 
    > 1. If two objects are equal, their hashcode will be same.
    > 2. If two object hashcode are same, you cannot guaranty that objects are equal.
    > 3. Overriding hashCode() method is said to be proper if and only if for every object we have to generate a unique number as hashcode for every object
    
    **3. equals();**
    
    > It compares the given object to this object.
    > 
    > 
    > If our class doesn't contain. `equals ()` method then `object class. equals ()` method will be executed which is always meant for reference comparison [address comparison]. i.e., if two references pointing to the same object then only. equals () method returns true.
    > 
    > ```java
    > public static void main(String[] args) { Employee emp1 = new Employee(); emp1.empId = 1;
    > emp1.empName = "Ashok";
    > 
    > Employee emp2 = new Employee(); emp2.empId = 2;
    > emp2.empName = "Sachin";
    > 
    > System.out.println(emp1.equals(emp2));
    > }
    > }
    > Output- false
    > ```
    > 
    
    **4. clone();**
    
    > It creates and returns the exact copy (clone) of this object.
    > 
    > 
    > The main objective of cloning is to maintain backup purposes. (i.e., if something goes wrong we can recover the situation by using backup copy.)
    > 
    > Example-
    > 
    > ```java
    > public class Example implements Cloneable {
    > 
    > int x;
    > 
    > public static void main(String[] args) throws
    > CloneNotSupportedException {
    > 
    > Example example1 = new Example(); example1.x = 50;
    > 
    > System.out.println("First Object data is>>" + example1.x);
    > Object example2 = example1.clone(); 
    > System.out.println("Second Object data is>>" + example2);
    > }
    > }
    > ```
    > 
    
    **5. getClass();**
    
    > This class is used to get the metadata of class ff.i.e. returns runtime class definition of an object
    > 
    
    **6. finalize();**
    
    > It is invoked by the garbage collector before object will be destroyed to       perform clean up activity.
    > 
    
    7. wait();
    
    8. wait();
    
    9.  wait();
    
    10. **notify();**
    
    > It wakes up single thread, waiting on this object's monitor.
    > 
    
    **11. notifyAll();**
    
    > It wakes up all the threads, waiting on this object's monitor.
    > 

## This & Super Keyword🔏

This and super are keywords in Java that refer to the current and parent class, respectively.

### **this**

- This keyword is used to refer to the current class's members, such as methods, variables, and constructors.
- This keyword can also be used to pass a reference to the current object to a constructor or method in another class.

### **super**

- The super keyword is used to refer to the parent class's members, such as methods, variables, and constructors.
- Super keyword can also be used to pass a reference to the parent object to a constructor or method in the current class.

Here is an example of using this and super in Java:

```java
class Parent {
  int x = 10;
  void display() {
    System.out.println("This is the parent class");
  }
}

class Child extends Parent {
  int x = 20;
  void display() {
    System.out.println("This is the child class");
    System.out.println("x in the parent class: " + super.x);
    System.out.println("x in the child class: " + x);
  }
}

public class Main {
  public static void main(String[] args) {
    Child c = new Child();
    c.display();
  }
}
```

This code will print the following:

```
This is the child class
x in the parent class: 10
x in the child class: 20
```

As you can see, the this keyword refers to the current class's members, while the super keyword refers to the parent class's members.

**Difference between super(),this() and super, this keyword:**

| super() this() | super, this |
| --- | --- |
| It is used for calling constructors | It is used to call method and variables |
| Using this, we can call immediate parent class and current class constructors | Using this, we can call immediate parent class and current class variables and methods. |
| It can be used only inside constructors | It can be used within instance(non-static) area only. |

*Point to be remember*

- We can use super() (or) this() only inside constructor. If we are using anywhere else we will get compile time error.
- We can use either super() (or) this() but not both simultaneously.
- We can use either super() (or) this() but not both simultaneously.

## ***Final keyword***

We can apply final to variables, method and class

### 1. *Final variable*

A variable which is declared with final keyword called as final variables.

Once you assigned any value to that variables then it won’t be changed. It works like constants in java.

How to declare the final variables- final int a=5;

### 2*.Final method*

Method which is defined with final keyword called as final method. How to declare the final method-

**public final void** test(){

//business logic here.

}

Note- Final method cannot be overridden.

### 3*. Final class*

The class which is defined with final keyword called as final class.

How to declare the final class

```java
final class Test {
// business logic
}
```

How you stop others from inheriting your class- By making class as final.

## Constructor

 A constructor in Java is a special method that is called when an object is created. It is used to initialize the object's data members. Constructors have the same name as the class they belong to and they do not have a return type.

**There are two types of constructors in Java:**

***1. No-arg constructors***: These constructors do not have any arguments. They are used to create objects with the default values for the data members.
***2. Parameterized constructors***: These constructors have arguments. They are used to create objects with specific values for the data members.

Here is an example of a no-arg constructor in Java:

```java
public class MyClass {

    public MyClass() {
        System.out.println("This is a no-arg constructor.");
    }
}
```

Here is an example of a parameterized constructor in Java:

```java
public class MyClass {

    public MyClass(int age) {
        System.out.println("This is a parameterized constructor.");
        this.age = age;
    }

    private int age;
}
```

When you create an object using the **`new`** keyword, the Java compiler automatically calls the constructor for that class. For example, the following code creates a new object of the **`MyClass`** class and calls the no-arg constructor:

```java
MyClass myObject = new MyClass();
```

The output of the following code is:

```
This is a no-arg constructor.
```

You can also call a constructor explicitly using the **`this()`** keyword. For example, the following code calls the parameterized constructor of the **`MyClass`** class:

```java
MyClass myObject = new MyClass(10);
```

The output of the following code is:

```
This is a parameterized constructor.
```

Constructors can be overloaded in Java. This means that you can have multiple constructors with the same name, but with different arguments. For example, the following code defines two constructors for the **`MyClass`** class:

```java
public class MyClass {

    public MyClass() {
        System.out.println("This is the first constructor.");
    }

    public MyClass(int age) {
        System.out.println("This is the second constructor.");
        this.age = age;
    }

    private int age;
}
```

When you create an object of the **`MyClass`** class, the Java compiler will choose the constructor that matches the arguments that you pass. For example, the following code creates a new object of the **`MyClass`** class and calls the first constructor:

```java
MyClass myObject = new MyClass();
```

The output of the following code is:

```
This is the first constructor.
```

If you pass an argument to the **`new`** keyword, the Java compiler will choose the constructor that has the same number and type of arguments as the argument that you pass. For example, the following code creates a new object of the **`MyClass`** class and calls the second constructor:

```java
MyClass myObject = new MyClass(10);
```

The output of the following code is:

```
This is the second constructor.
```

You can also use the **`this()`** keyword to call a constructor from another constructor. For example, the following code calls the first constructor from the second constructor:

```java
public class MyClass {

    public MyClass() {
        this(10);
        System.out.println("This is the first constructor.");
    }

    public MyClass(int age) {
        System.out.println("This is the second constructor.");
        this.age = age;
    }

    private int age;
}
```

The output of the following code is:

```
This is the second constructor.
This is the first constructor.
```

Constructors are an important part of Java object-oriented programming. They allow you to initialize the data members of an object when it is created. Constructors can also be used to perform other tasks, such as creating other objects or initializing the object's state.

# 3. ***Exception handling in java***

Exception is the abnormal condition that occur during execution of program to stop the entire flow of application called as “Exception.”

It is highly recommended to handle exceptions. The main objective of exception handling is normal (graceful) termination of the program.

Exception handling doesn't mean repairing an exception. We have to define alternative way to continue rest of the program normally. This way of defining alternative is nothing but exception handling.

### **Exception Hierarchy:**

- All exceptions in Java are derived from the **`java.lang.Throwable`** class. It has two main subclasses: **`Error`** and **`Exception`**.
- The **`Exception`** class is further divided into checked and unchecked exceptions.

### **finally-**

The finally block is used when an important part of the code needs to be executed. It is always executed whether or not the exceptions are handled.

- Finally block will always get executed until we shut down JVM. To shut down JVM in java we call System.exit (). If you write this in try block in that case finally block will not be executed.
- Normally, finally block contains the code to release resources like DB connections, IO streams etc

### Checked **Exceptions** vs unchecked Exception:

| Checked Exceptions | Unchecked Exceptions (Runtime Exceptions) |
| --- | --- |
| Compile-Time Checking: Checked exceptions are checked at compile time. | Runtime Checking: Unchecked exceptions, also known as runtime exceptions, are not checked at compile time. |
| Forcing Exception Handling: Checked exceptions are typically used for conditions that are outside the control of the program. The Java compiler requires you to either handle these exceptions using a try-catch block or declare that your method can throw these exceptions using the throws keyword. | Programming Errors: Unchecked exceptions are often associated with programming errors or exceptional conditions that should not normally occur in a well-written program. They are only checked at runtime and indicate issues like null pointer dereference, division by zero, or array index out of bounds. |
| Examples: IOException, FileNotFoundException, SQLException, ClassNotFoundException, etc. | Examples: NullPointerException, ArithmeticException, ArrayIndexOutOfBoundsException, ClassCastException, IllegalArgumentException, etc. |
| Usage: Checked exceptions are commonly used for situations where there's a reasonable expectation that the error might occur, and you want to handle it gracefully. For example, when working with file I/O, it's common to encounter IOExceptions, so they are checked exceptions to encourage handling. | Usage: Unchecked exceptions are typically used for situations where it is difficult or unnecessary to predict and handle the exceptions explicitly. These exceptions usually indicate flaws in the code that need to be fixed during development. |

### Catch Vs Finally :

| catch Block | finally Block |
| --- | --- |
| Purpose: The catch block is used to handle exceptions that are thrown within the try block. | Purpose: The finally block is used to define a block of code that is executed regardless of whether an exception occurred or not. |
| Exception Handling: Each catch block is associated with a specific type of exception. If the type of exception thrown in the try block matches the type specified in the catch block, the code inside that catch block is executed. | Execution Guarantee: The code inside the finally block is guaranteed to execute, even if no exception was thrown in the try block. It runs after the try block and any applicable catch block(s). |
| Multiple catch Blocks: You can have multiple catch blocks to handle different types of exceptions. Java will execute the first catch block whose exception type matches the thrown exception, and subsequent catch blocks are ignored. | Use Cases: The finally block is commonly used to release resources like closing files, database connections, or cleaning up after an operation, ensuring that essential cleanup code is always executed. |
| Example:  | Example: |
| try {
// Code that may throw an exception
} catch (ExceptionType1 e1) {
// Handle ExceptionType1
} catch (ExceptionType2 e2) {
// Handle ExceptionType2
} | try {
// Code that may throw an exception
} catch (ExceptionType e) {
// Handle the exception
} finally {
// Cleanup code or resource release
} |

### *Differences between "final," "finally," and "finalize”:*

| final | finally | finalize |
| --- | --- | --- |
| Purpose: final is used to declare variables, methods, or classes as unchangeable, immutable, or constant. | Purpose: finally is a block associated with a try-catch block and ensures that a specific block of code is executed, regardless of whether an exception is thrown or not. | Purpose: finalize is a method in Java's Object class used for cleanup before an object is garbage collected. |
| Variable: When a variable is declared as final, its value cannot be modified after initialization. | Exception Handling: The finally block is used for cleanup or resource release in the context of exception handling. | Garbage Collection: The finalize method is called by the garbage collector before an object is removed from memory. |
| Method: When a method is declared as final, it cannot be overridden by subclasses. |  | Resource Cleanup: It's used for cleaning up resources associated with an object, but it's considered somewhat deprecated in modern Java programming. |
| Class: When a class is declared as final, it cannot be extended (subclassed). |  |  |
| Example Usage: | Example Usage: | Example Usage: |
| final int constantValue = 42; | try {
    // Code that may throw an exception
} catch (Exception e) {
    // Handle the exception
} finally {
    // Cleanup code or resource release
} | protected void finalize() {
    // Clean up resources before the object is garbage collected
} |

## ***Throw and Throws***

### ***Throw-***

- The throw keyword is used to create our own Exception object and handover it to JVM manually.
- It is used for custom exception.
- After throw statement, we can’t take any other statement as it will become unreachable.

Example:

- throw new `InsufficientFundException` ();

### ***Throws-***

Throws keyword is used to declare the exception with method.

It is used to delegate the responsibility of exception handling to the caller method. Then caller method is responsible to handle that exception.

**Note:**

- Hence the main objective of "throws" keyword is to delegate the responsibility of exception handling to the caller method.
- "throws" keyword required only checked exceptions. Usage of throws for unchecked exception there is no use.
- "throws" keyword required only to convince complier. Usage of throws keyword doesn't prevent abnormal termination of the program.
- Hence recommended to use try-catch over throws keyword.
- We can use throws keyword only for constructors and methods but not for classes.

Example-

```java
void m1() throws IOException{  
    m2();  
}
```

### What is the difference between throw and throws? (Self-assignment)

| throw | throws |
| --- | --- |
| Purpose: throw is used to manually throw an exception in your code when a specific condition is met. | Purpose: throws is used in a method declaration to specify the exceptions that the method might throw. |
| Usage: You use throw within a method to raise an exception when an exceptional condition is encountered, allowing you to handle exceptional cases in your code. | Usage: You use throws in a method signature to declare the exceptions that the method can potentially throw, informing callers of the method about the types of exceptions they should handle. |
| Example: Here's an example of using throw to throw a custom exception: | Example: Here's an example of using throws in a method declaration: |
| if (conditionIsMet) {
throw new CustomException("This is a custom exception message");
} | public void doSomething() throws IOException, CustomException {
    // Method code that may throw IOException or CustomException
} |

### Q. How To create Custom Exception In java ?

> Here are the steps to create a custom exception in Java:
> 

**Step 1: Create a Custom Exception Class**

1. Create a new Java class that represents your custom exception. Give it a descriptive name, and it should extend an existing exception class, such as `Exception` or one of its subclasses like `RuntimeException`, depending on whether you want it to be a checked or unchecked exception.
    
    ```java
    public class CustomException extends Exception {
        // Add a constructor and any additional methods or fields as needed
    }
    
    ```
    
    If you want to create an unchecked exception, you can extend `RuntimeException`:
    
    ```java
    public class CustomRuntimeException extends RuntimeException {
        // Add a constructor and any additional methods or fields as needed
    }
    
    ```
    

**Step 2: Define a Constructor**

1. Inside your custom exception class, define at least one constructor. The constructor can take parameters to customize the exception message or behavior. You can use the `super` keyword to call the constructor of the parent class (e.g., `Exception` or `RuntimeException`) and pass a message.
    
    ```java
    public CustomException(String message) {
        super(message);
    }
    
    ```
    

**Step 3: Optional Customization**

1. You can add any additional methods, fields, or behavior specific to your custom exception if needed. For example, you can create custom methods to provide more information about the exception.
    
    ```java
    public class CustomException extends Exception {
        public CustomException(String message) {
            super(message);
        }
    
        public String getCustomInfo() {
            return "Additional information about the exception.";
        }
    }
    
    ```
    

**Step 4: Throwing the Custom Exception**

1. In your code, when an exceptional situation occurs that matches the conditions for your custom exception, you can throw it using the `throw` keyword.
    
    ```java
    if (someCondition) {
        throw new CustomException("This is a custom exception message");
    }
    
    ```
    
    Or, if you are using an unchecked (runtime) custom exception:
    
    ```java
    if (someCondition) {
        throw new CustomRuntimeException("This is a custom runtime exception message");
    }
    
    ```
    

**Step 5: Handling the Custom Exception (Optional)**

1. If you want to handle your custom exception, you can use a `try-catch` block to catch it and perform specific actions. Make sure to handle the custom exception as you would with any other exception.
    
    ```java
    try {
        // Code that may throw a custom exception
    } catch (CustomException e) {
        // Handle the custom exception
        System.out.println("Custom Exception caught: " + e.getMessage());
    }
    
    ```
    

That's it! 

## Input-Output in java

1. **What is Java I/O?**
    - Java I/O (Input/Output) is a mechanism that allows Java programs to interact with external resources, such as files, databases, network sockets, and user input/output.
2. **Key Classes for I/O:**
    - In Java, key classes for I/O operations are `InputStream`, `OutputStream`, `Reader`, and `Writer`.
3. **Byte vs. Character Streams:**
    - Java I/O is categorized into byte-oriented and character-oriented streams. Byte streams work with raw binary data, while character streams handle text data.
4. **`System.in` and `System.out`:**
    - `System.in` is an input stream that represents the standard input (usually the keyboard), and `System.out` is an output stream that represents the standard output (usually the console).
5. **File I/O:**
    - File I/O is common for reading and writing files in Java. Key classes include `FileInputStream`, `FileOutputStream`, `FileReader`, and `FileWriter`.
6. **Buffered I/O:**
    - Buffered I/O uses buffer streams (`BufferedReader`, `BufferedWriter`, `BufferedInputStream`, `BufferedOutputStream`) to improve I/O performance by reading/writing data in chunks.
7. **Serialization:**
    - Serialization is the process of converting objects into a stream of bytes. Java provides `ObjectInputStream` and `ObjectOutputStream` for this purpose.
8. **Input from Keyboard:**
    - `Scanner` is often used to read input from the keyboard in a convenient way.
9. **Exceptions in I/O:**
    - I/O operations can throw various exceptions, such as `IOException`. Handling these exceptions is crucial for robust I/O code.
10. **Read and Write Text Files:**
    - For reading and writing text files, use `FileReader` and `FileWriter` for character data and `BufferedReader` and `BufferedWriter` for efficiency.
11. **Read and Write Binary Files:**
    - For reading and writing binary files, use `FileInputStream` and `FileOutputStream` for byte data and `DataInputStream` and `DataOutputStream` for structured binary data.
12. **Standard Streams Redirection:**
    - You can redirect standard input and output using `System.setIn()` and `System.setOut()` to read/write data from/to files or other sources.
13. **NIO (New I/O):**
    - Java NIO provides the `java.nio` package with features like channels, buffers, and non-blocking I/O for advanced I/O operations.
14. **Working with URLs:**
    - Java provides classes like `URL` and `URLConnection` for reading data from URLs.
15. **Character Encoding:**
    - Be aware of character encoding when working with character streams and internationalization. UTF-8 is a commonly used encoding for cross-platform compatibility.
16. **Handling Large Files:**
    - When dealing with large files, consider using NIO's `MappedByteBuffer` or streaming techniques to avoid loading the entire file into memory.
17. **Closable Resources:**
    - Always close I/O resources (streams, readers, writers) using try-with-resources or explicitly in a `finally` block to release system resources.

## *Serialization and deserialization*

Serialization and deserialization in Java are concepts used for saving and restoring the state of objects. They are essential for tasks like persisting data, sending objects over a network, and storing objects in files or databases. 

### ***Serialization*:**

***Purpose*:** Serialization is the process of converting an object's state (its instance variables) into a byte stream, which can be saved to a file, sent over a network, or stored in a database. This allows you to "freeze" the state of an object for later use.

***How It Works:***

1. Java uses the `java.io.Serializable` interface. If a class implements this interface, it's considered serializable.
2. During serialization, an object is converted into a sequence of bytes. This process includes saving the object's state, including the values of its fields.
3. The serialized data can then be written to a file or sent over a network.

**Example: Serialization**

Let's create a simple example of serialization:

```java
import java.io.*;

class Person implements Serializable {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

public class SerializationExample {
    public static void main(String[] args) {
        Person person = new Person("Alice", 30);

        try (ObjectOutputStream out = 
new ObjectOutputStream(new FileOutputStream("person.ser"))) {
            out.writeObject(person); 
// Serialize the object and write it to a file
            System.out.println("Serialization completed.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

```

In this example, we have a `Person` class that implements `Serializable`. We create a `Person` object and serialize it to a file named "person.ser."

### ***Deserialization:***

***Purpose*:** Deserialization is the process of converting a byte stream back into an object. It allows you to "thaw" a previously serialized object, restoring its state.

Deserialization is the process of taking an object that was saved as a bunch of bytes (like freezing it) and turning it back into a real, usable object with all its original information and functionality (unfreezing it). It's like restoring a previously saved object to its original state.

***How It Works:***

1. To perform deserialization, you need to read the serialized data from a file or a source like a network stream.
2. Java reads the serialized data and reconstructs the object, including its fields, by following the class structure.
3. The class must be available in the classpath and be compatible with the serialized data.

**Example: Deserialization**

Let's continue with our previous example by deserializing the `Person` object:

```java
import java.io.*;

class Person implements Serializable {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" + "name='" + name + "', age=" + age + '}';
    }
}

public class DeserializationExample {
    public static void main(String[] args) {
        try (ObjectInputStream in = 
new ObjectInputStream(new FileInputStream("person.ser"))) {
            Person person = (Person) in.readObject(); // Deserialize the object
            System.out.println("Deserialization completed.");
            System.out.println("Deserialized Object: " + person);
        } catch (IOException | ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}

```

In this example, we read the serialized data from "person.ser" and deserialize it back into a `Person` object.

**Important Considerations:**

- Serialization and deserialization should be used with care, as they can have security implications if used inappropriately.
- Ensure that the class version remains compatible during object evolution to prevent issues during deserialization.
- Serialization can be used for various purposes, including saving the state of an application, sending objects over a network, and caching data.

> **Serialization and Deserialization:**
> 
> - Serialization is the process of converting an object into a stream of bytes using `ObjectOutputStream`.
> - Deserialization is the process of reconstructing an object from a stream of bytes using `ObjectInputStream`.
> 1. **Inheritance and Serialization:**
>     - If a superclass implements the `Serializable` interface, its subclasses are automatically serializable.
> 2. **Static Members:**
>     - Static members (fields or methods) are not serialized because they belong to the class, not the object.
> 3. **Using "transient":**
>     - You can use the `transient` keyword to exclude specific fields from serialization. They won't be saved.
> 4. **Custom Serialization:**
>     - You can implement custom serialization methods to control how your objects are serialized and deserialized.
> 5. **Partial Serialization:**
>     - You can partially serialize an object using externalization, a mechanism that allows you to customize the serialization process.
> 6. **Array or Collection Serialization:**
>     - All objects within an array or collection must be serializable for successful serialization of the array or collection.
> 7. **Serial Version UID:**
>     - Each serializable class has a version number (`serialVersionUID`) used to verify compatibility during deserialization.
> 8. **Custom Serial Version UID:**
>     - A class can specify its own `serialVersionUID` for version control by declaring a `static final long serialVersionUID` field.
> 9. **Transient and Superclass Variables:**
>     - If a variable in a superclass is made `transient`, it's reset to default values (like 0 or null) after deserialization.
> 10. **Order of Serialization and Deserialization:**
>     - Objects must be deserialized in the same order they were serialized to reconstruct the state correctly.

## ***Arrays in Java**:*

---

Arrays are a fundamental data structure in Java that allow you to store multiple values of the same data type in a single variable. They provide a way to efficiently manage collections of elements. Here are some key points about arrays in Java:

**1. Declaration and Initialization:**

- Arrays are declared using square brackets, like `int[] numbers;`.
- They can be initialized when declared, such as `int[] numbers = {1, 2, 3};`, or with a specific size, like `int[] numbers = new int[5];`.

**2. Fixed Size:**

- Arrays in Java have a fixed size that is determined at the time of creation. Once the size is set, it cannot be changed.

**3. Zero-Based Indexing:**

- Elements in an array are accessed using a zero-based index. The first element is at index 0, the second at 1, and so on.

**4. Homogeneous Elements:**

- Arrays can store elements of the same data type. If you need to store different data types, you can use arrays of objects (`Object[]`) or collections.

**5. Length Property:**

- Arrays have a `length` property that indicates the number of elements in the array. It's accessed as `array.length`.

**6. Accessing Elements:**

- You can access elements using square brackets, like `numbers[0]` to access the first element.

**7. Iterating Through Arrays:**

- Use loops (e.g., `for` or `foreach`) to iterate through the elements of an array.

**8. Array Copy:**

- The `System.arraycopy` method or the `Arrays.copyOf` method is used to copy elements from one array to another.

**9. Multidimensional Arrays:**

- Java supports multidimensional arrays, like arrays of arrays. You can have 2D arrays, 3D arrays, and so on.

**10. Array Manipulation:**
- Arrays offer various utility methods like `Arrays.sort`, `Arrays.binarySearch`, and `Arrays.fill` to manipulate their elements.

**11. Limitations:**
- Arrays have a fixed size, which can be limiting if the size of the collection is unknown or may change frequently. In such cases, collections like `ArrayList` are more flexible.

Arrays are a fundamental building block for many data structures and algorithms in Java. They offer fast and direct access to elements, making them efficient for many tasks. However, understanding their fixed size and limitations is essential for effective use.

## ***String Class in Java***

---

The `String` class in Java is a fundamental class that represents sequences of characters. It's widely used in Java applications for handling text and character data. Here are some key points about the `String` class:

---

- **Q. What is Immutability?**
    
    **Immutability** refers to the property of an object that, once created, cannot be modified. In the context of the `String` class in Java, immutability means that a `String` object's value cannot be changed after it is created. Instead, any operation that appears to modify a `String` actually creates a new `String` object with the desired changes.
    
    ---
    
- **Q. Why is `String` Immutable in Java?**
    
    There are several reasons why the `String` class in Java is designed to be immutable:
    
    1. **Thread Safety:** Immutable objects are inherently thread-safe because they cannot be modified once created. This property simplifies multi-threaded programming, as multiple threads can safely access and share `String` objects without the risk of data corruption or race conditions.
    2. **Caching and Reusability:** Strings in Java are commonly used and frequently duplicated. By making them immutable, Java can store and reuse the same string in memory (through the string pool) when the same value is needed again. This reduces memory consumption and improves performance.
    3. **Security:** Strings are often used to store sensitive data like passwords. Immutability ensures that once a string is set, it cannot be altered accidentally or maliciously.
    4. **Predictable Behavior:** Immutability guarantees that a `String` object's value remains constant, making code more predictable and easier to reason about. It simplifies debugging and ensures that a method or operation on a  does not have unintended side effects.
    
- **Q. How Java Achieves String Immutability:**
    1. **Final Class:** The `String` class is declared as `final`, meaning it cannot be extended or subclassed. This prevents any attempts to create mutable subclasses.
    2. **Private Final Char Array:** The underlying character array in a `String` is declared as `private` and `final`. This means it cannot be accessed or modified from outside the  class.
    3. **No Setter Methods:** The `String` class does not provide any methods that allow you to change the content of a  directly. Operations like concatenation or substring creation return new  objects.
    4. **String Pool:** Java maintains a pool of string literals. When you create a string with the same content as an existing string, Java may return a reference to the existing string from the pool, rather than creating a new one. This reuse of string values contributes to immutability.
    
    In summary, Java achieves the immutability of the `String` class by design, using `final` classes, private and final fields, and by not providing any methods that modify the string's content directly. This design ensures that once a `String` object is created, its value remains constant, contributing to predictability, thread safety, and performance optimization.
    
- **Q. What is String Pool? How it works?**
    
    **String Pool** is a special area in the Java memory where string literals are stored. It is designed to optimize memory usage by reusing common string values, rather than creating new instances of the same strings. This reduces memory overhead and improves performance. Here's a detailed explanation of the Java String Pool with examples:
    
    **How the String Pool Works:**
    
    1. When you create a string literal in your code, Java checks if an equivalent string already exists in the String Pool.
    2. If a matching string is found in the pool, Java returns a reference to that existing string instead of creating a new one.
    3. If no match is found, a new string is created in the String Pool.
    
    **Example 1: Basic String Pool Usage**
    
    ```java
    String str1 = "Hello"; // Creates a new string "Hello" in the pool
    String str2 = "Hello"; // Reuses the existing string "Hello" from the pool
    
    ```
    
    In this example, `str1` and `str2` both reference the same "Hello" string in the pool, which saves memory.
    
    **Example 2: Concatenation and the String Pool**
    
    ```java
    String str3 = "Java";   // Creates a new string "Java" in the pool
    String str4 = " is ";   // Creates a new string " is " in the pool
    String str5 = "fun!";   // Creates a new string "fun!" in the pool
    String result = str3 + str4 + str5; // Creates a new string "Java is fun!" in the pool
    
    ```
    
    Even during string concatenation, Java checks the String Pool. In this example, `result` references a new string, "Java is fun!", which is created in the pool.
    
    **Example 3: Creating Strings Without the String Pool**
    
    ```java
    String str6 = new String("Hello"); // Forces the creation of a new string "Hello" outside the pool
    String str7 = new String("Hello"); // Forces the creation of another new string "Hello" outside the pool
    
    ```
    
    Using the `new` keyword explicitly creates strings outside the pool, and `str6` and `str7` reference different objects, even though their contents are the same.
    
    **Example 4: String Interning**
    
    ```java
    String str8 = new String("Java"); // Creates a new string "Java" outside the pool
    str8 = str8.intern(); // Manually interns the string, placing it in the String Pool
    String str9 = "Java"; // Reuses the interned string "Java" from the pool
    
    ```
    
    You can manually intern a string using the `intern()` method. In this example, `str8` initially creates a new string outside the pool but is later interned, allowing `str9` to reuse it.
    
    **Why Use the String Pool:**
    
    - **Memory Efficiency**: Reusing strings in the pool reduces memory consumption, especially when dealing with many identical strings.
    - **Performance**: String comparisons are faster when using references, as compared to comparing the contents of strings.
    
    While the String Pool is a useful memory optimization feature, it's important to understand how it works and when to use it, especially when dealing with strings that should not be interned (e.g., dynamically generated or large strings).
    
- **Q. important methods of String Class?**
    
    The `String` class in Java provides a wide range of methods for working with strings. Here are some important methods of the `String` class:
    
    **1. `length()`:** Returns the length of the string (the number of characters).
    
    ```java
    String str = "Hello, World!";
    int length = str.length(); // length is 13
    ```
    
    **2. `charAt(int index)`:** Returns the character at the specified index.
    
    ```java
    char character = str.charAt(7); // character is 'W'
    ```
    
    **3. `substring(int beginIndex)`:** Returns a substring starting from the specified index.
    
    ```java
    String sub = str.substring(7); // sub is "World!"
    ```
    
    **4. `substring(int beginIndex, int endIndex)`:** Returns a substring in the specified range.
    
    ```java
    String sub = str.substring(7, 12); // sub is "World"
    ```
    
    **5. `equals(Object obj)`:** Compares the content of two strings for equality.
    
    ```java
    boolean isEqual = str.equals("Hello, World!"); // isEqual is true
    ```
    
    **6. `equalsIgnoreCase(String another)`:** Compares two strings, ignoring case.
    
    ```java
    boolean isEqualIgnoreCase = str.equalsIgnoreCase("hello, world!"); 
    // isEqualIgnoreCase is true
    ```
    
    **7. `compareTo(String another)`:** Compares two strings lexicographically.
    
    ```java
    int comparison = str.compareTo("Goodbye"); // comparison is greater than 0
    ```
    
    **8. `startsWith(String prefix)`:** Checks if the string starts with the specified prefix.
    
    ```java
    boolean startsWith = str.startsWith("Hello"); // startsWith is true
    
    ```
    
    **9. `endsWith(String suffix)`:** Checks if the string ends with the specified suffix.
    
    ```java
    boolean endsWith = str.endsWith("World!"); // endsWith is true
    ```
    
    **10. `contains(CharSequence sequence)`:** Checks if the string contains the specified sequence.
    
    ```java
    boolean contains = str.contains("World"); // contains is true
    ```
    
    **11. `indexOf(String str)`:** Returns the index of the first occurrence of the specified string.
    
    ```java
    int index = str.indexOf("World"); // index is 7
    ```
    
    **12. `lastIndexOf(String str)`:** Returns the index of the last occurrence of the specified string.
    
    ```java
    int lastIndex = str.lastIndexOf("l"); // lastIndex is 10
    
    ```
    
    **13. `replace(CharSequence target, CharSequence replacement)`:** Replaces all occurrences of the target with the replacement.
    
    ```java
    String replaced = str.replace("o", "0"); // replaced is "Hell0, W0rld!"
    
    ```
    
    **14. `toUpperCase()`:** Converts the string to uppercase.
    
    ```java
    String upper = str.toUpperCase(); // upper is "HELLO, WORLD!"
    
    ```
    
    **15. `toLowerCase()`:** Converts the string to lowercase.
    
    ```java
    String lower = str.toLowerCase(); // lower is "hello, world!"
    
    ```
    
    **16. `trim()`:** Removes leading and trailing whitespace.
    
    ```java
    String trimmed = "  Hello, World!  ".trim(); // trimmed is "Hello, World!"
    
    ```
    
    **17. `split(String regex)`:** Splits the string into an array of substrings using a regular expression.
    
    ```java
    String[] parts = str.split(", "); // parts is {"Hello", "World!"}
    
    ```
    
    **18. `isEmpty()`:** Checks if the string is empty (has a length of 0).
    
    ```java
    boolean empty = str.isEmpty(); // empty is false
    
    ```
    

**1. Immutability:**

- Strings in Java are immutable, meaning their values cannot be changed once they are created. Any operation that appears to modify a string actually creates a new string.

**2. String Literals:**

- String literals (e.g., `"Hello"`) are created on the string pool, which allows multiple references to the same string to share the same memory.

**3. Concatenation:**

- Strings can be concatenated using the `+` operator or the `concat` method. This creates a new string with the combined content.

**4. String Comparison:**

- Use `.equals()` for comparing the contents of two strings, and `==` to compare their references (addresses in memory).

**5. Length:**

- The length of a string can be obtained using the `length()` method.

**6. Character Access:**

- Individual characters within a string can be accessed using the `.charAt(index)` method.

**7. Substrings:**

- Substrings can be extracted using the `.substring(startIndex, endIndex)` method.

**8. String Methods:**

- The `String` class provides various methods for string manipulation, including searching, replacing, case conversion, and more.

**9. Escape Sequences:**

- Special characters within strings are often represented using escape sequences (e.g., `\\n` for a new line).

**10. String Conversion:**
- You can convert other data types to strings using methods like `.valueOf()` or by concatenation.

**11. StringBuilder and StringBuffer:**
- For efficient string manipulation in scenarios involving frequent changes, `StringBuilder` (not thread-safe) and `StringBuffer` (thread-safe) are recommended due to their mutable nature.

**12. Unicode Support:**
- Java `String` objects are UTF-16 encoded, providing support for a wide range of international characters.

**13. Null vs. Empty String:**
- An empty string `""` is not the same as a `null` string reference. An empty string is a valid object, while a `null` reference represents the absence of an object.

**14. Performance Considerations:**
- Due to string immutability, avoid excessive string concatenation in loops, as it can create many temporary objects.

The `String` class is essential for working with text data in Java applications. Its immutability ensures thread-safety, and its rich set of methods simplifies common string operations. Understanding how strings are stored and manipulated in Java is crucial for efficient and bug-free code.

## ***Multithreading in Java:***

Multithreading in Java is a powerful concept that allows you to execute multiple threads or concurrent tasks within a single program. Here's an elaborative explanation of multithreading in Java, including the concepts, how to create and manage threads, and advantages:

- **Q. What is Multithreading?**
    
    Multithreading is the process of executing multiple threads (smaller units of a program) simultaneously. Each thread represents a separate flow of control and can perform tasks independently. Multithreading is a key feature in Java that enables efficient utilization of modern multi-core processors.
    

**Types of Multitasking:**
There are two ways to achieve multitasking in Java:

1. **Process-based Multitasking:** Executing several tasks as separate, independent processes. Each task runs in its own process, with its own memory space.
2. **Thread-based Multitasking:** Executing multiple tasks as separate parts of the same program. Threads share the same memory space, allowing them to communicate and share data easily.

**Thread Creation:**
In Java, you can create threads in two ways:

1. **Extending the `Thread` Class:** You can create a thread by extending the `Thread` class and overriding the `run()` method. This approach is suitable when you want to encapsulate the thread's behavior within the class itself.
2. **Implementing the `Runnable` Interface:** You can implement the `Runnable` interface, which allows you to separate the thread's behavior from the class. This is especially useful when your class already extends another class.

**Thread Lifecycle:**
Threads go through various states in their lifecycle, including `NEW`, `RUNNABLE`, `BLOCKED`, `WAITING`, `TIMED_WAITING`, and `TERMINATED`. Understanding these states is essential for managing threads effectively.

**Common Thread Methods:**

- `run()`: The method where you define the thread's logic.
- `start()`: Initiates the execution of the thread by calling the `run()` method. It's important to call `start()` rather than `run()` to create a new thread.
- `sleep()`: Temporarily pauses the thread's execution for a specified time.
- `join()`: Waits for a thread to complete.
- `getPriority()`: Gets the thread's priority.
- `setPriority()`: Sets the thread's priority.
- `getName()`: Gets the thread's name.
- `setName()`: Sets the thread's name.

**Thread Synchronization:**
Multithreading can lead to race conditions and data corruption. Synchronization mechanisms like `synchronized` blocks and methods are used to ensure that only one thread accesses a critical section of code at a time.

**Advantages of Multithreading in Java:**

1. **Improved Performance:** Multithreading allows for parallel execution, making use of multi-core processors and significantly improving the overall performance of an application.
2. **Responsiveness:** Multithreaded applications remain responsive, as tasks can be executed independently without blocking the user interface.
3. **Resource Utilization:** It optimizes resource utilization by enabling multiple tasks to run concurrently, preventing idle CPU cycles.

**Example Program - Multithreading in Java:**

```java
class MyThread extends Thread {
    public void run() {
        for (int i = 1; i <= 10; i++) {
            System.out.println(i);
        }
    }
}
public class ThreadDemo {
    public static void main(String[] args) {
        MyThread thread = new MyThread();
        thread.start();
    }
}
```

This program demonstrates the creation and execution of a simple thread.

Multithreading in Java offers a powerful mechanism for building responsive and efficient applications. However, it also introduces complexities, such as synchronization and thread safety, which need to be carefully managed to ensure correct and efficient behavior.

### *Thread Lifecycle:*

1. **NEW:** When a thread is created using the `Thread` class constructor, it initially exists in the `NEW` state. At this point, the thread is not yet started and is not executing its `run()` method.
2. **RUNNABLE:** After calling the `start()` method, the thread moves to the `RUNNABLE` state. In this state, the thread is ready to run but may be waiting for its turn to be scheduled by the operating system.
3. **RUNNING:** Once the thread is scheduled by the operating system, it enters the `RUNNING` state. It actively executes its `run()` method.
4. **BLOCKED:** A thread can transition to the `BLOCKED` state when it is waiting for a monitor lock (e.g., when entering a synchronized block or method) held by another thread. The `BLOCKED` thread is waiting for its turn to obtain the lock.
5. **WAITING:** Threads can enter the `WAITING` state when they are explicitly made to wait using methods like `wait()`, `join()`, or `sleep()`. In this state, the thread is waiting for some condition to be satisfied before it can proceed.
6. **TIMED_WAITING:** Similar to the `WAITING` state, a thread enters the `TIMED_WAITING` state when it is waiting for a specific amount of time. This occurs when methods like `sleep()` or `join(timeout)` are used.
7. **TERMINATED:** A thread reaches the `TERMINATED` state when it completes the execution of its `run()` method or is explicitly stopped using the `stop()` method (not recommended). In this state, the thread's execution is finished, and it cannot be restarted.

Here's a diagram illustrating the thread lifecycle:

```
NEW -> RUNNABLE -> RUNNING -> (BLOCKED or WAITING or TIMED_WAITING) -> TERMINATED
```

### *Synchronization :*

Synchronization in Java is a technique used to control access to shared resources, ensuring that only one thread can access the resource at a time. This is crucial in multithreaded applications to prevent race conditions and maintain data consistency. You can use the `synchronized` keyword, locks, or synchronized methods to achieve synchronization. Here's an example of synchronization using the `synchronized` keyword:

```java
class SharedResource {
    synchronized void printNumbers() {
        for (int i = 1; i <= 5; i++) {
            System.out.println(i);
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

class MyThread extends Thread {
    SharedResource resource;

    MyThread(SharedResource resource) {
        this.resource = resource;
    }

    public void run() {
        resource.printNumbers();
    }
}

public class SynchronizationExample {
    public static void main(String[] args) {
        SharedResource resource = new SharedResource();
        MyThread thread1 = new MyThread(resource);
        MyThread thread2 = new MyThread(resource);

        thread1.start();
        thread2.start();
    }
}

```

In this example, we have a `SharedResource` class with a `synchronized` method `printNumbers()`. The `printNumbers()` method prints numbers from 1 to 5 with a small delay between each print.

We create two threads, `thread1` and `thread2`, and both share the same `SharedResource` object. When these threads start, they call the `printNumbers()` method, which is synchronized. This means only one thread can execute this method at a time.

As a result, the output will be synchronized, ensuring that the numbers are printed by one thread before the other starts printing. This prevents interleaved or inconsistent output, demonstrating how synchronization can be used to manage access to shared resources in multithreaded environments.

Here's a sample output:

```
1
2
3
4
5
1
2
3
4
5

```

In this output, you can see that `thread1` prints the numbers from 1 to 5, and only after it completes, `thread2` prints the same sequence of numbers. This synchronization ensures the order and consistency of the output.

**RealTime Example**

Here's the code with synchronization applied to the `makeWithdrawal` method for reference:

```java
package com.synchronizations;

public class Account {

    private int balance = 5000;

    public int getBalance() {
        return balance;
    }

    public synchronized int withdraw(int amount) {
        if (balance >= amount) {
            System.out.println(Thread.currentThread().getName() + " is going to withdraw => " + amount);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                System.out.println(e.getMessage());
            }
            balance -= amount;
            System.out.println(Thread.currentThread().getName() + " completed the withdrawal, Avl bal => " + balance);
        } else {
            System.out.println(Thread.currentThread().getName() + " cannot withdraw due to insufficient balance.");
        }
        return balance;
    }
}

package com.synchronizations;

public class AccountDetails implements Runnable {

    Account account = new Account();

    @Override
    public void run() {
        for (int x = 0; x < 5; x++) {
            account.withdraw(500);

            if (account.getBalance() <= 0) {
                System.out.println("Account is overdrawn...");
            }
        }
    }
}

package com.synchronizations;

public class MainTest {

    public static void main(String[] args) {
        AccountDetails accountDetails = new AccountDetails();
        Thread thread1 = new Thread(accountDetails);
        Thread thread2 = new Thread(accountDetails);
        thread1.setName("Rohan");
        thread2.setName("Soham");
        thread1.start();
        thread2.start();
    }
}

```

In this code, the `withdraw` method of the `Account` class has been synchronized using the `synchronized` keyword. This ensures that only one thread can execute this method at a time, preventing race conditions and maintaining data consistency.

With this synchronization, you will get output like this:

```java
Soham is going to withdraw => 500
Soham completed the withdrawal, Avl bal => 4500
Soham is going to withdraw => 500
Soham completed the withdrawal, Avl bal => 4000
Soham is going to withdraw => 500
Soham completed the withdrawal, Avl bal => 3500
Soham is going to withdraw => 500
Soham completed the withdrawal, Avl bal => 3000
Soham is going to withdraw => 500
Soham completed the withdrawal, Avl bal => 2500
Rohan is going to withdraw => 500
Rohan completed the withdrawal, Avl bal => 2000
Rohan is going to withdraw => 500
Rohan completed the withdrawal, Avl bal => 1500
Rohan is going to withdraw => 500
Rohan completed the withdrawal, Avl bal => 1000
Rohan is going to withdraw => 500
Rohan completed the withdrawal, Avl bal => 500
Rohan is going to withdraw => 500
Rohan completed the withdrawal, Avl bal => 0
Account is overdrawn...

```

This synchronized code ensures that the `withdraw` method is executed by one thread at a time, maintaining the correctness of the account balance and preventing overdrawing.

# ***4.Collection Interface:***

---

### *Why Is It Called a Framework?*

The Java Collections Framework is referred to as a "framework" because it provides a structured and comprehensive set of classes and interfaces that work together seamlessly. It serves as a foundation for dealing with collections of objects in Java. This framework defines a set of common methods and behaviors that can be applied to different types of collections, making it easy to work with and manipulate data.

### *Need for Collections:*

1. ***Dynamic Size**:* Unlike arrays, collections are dynamic and can grow or shrink as needed. This flexibility is crucial when dealing with varying amounts of data.
2. ***Support for Heterogeneous Data**:* Collections can store a mix of different data types (heterogeneous elements), making them versatile for various scenarios.
3. ***Ready-Made Methods**:* Collections come with a set of built-in methods, making it easier to perform operations like searching, sorting, and filtering.

### *Differences Between Arrays and Collections:*

| Aspect | Arrays | Collections |
| --- | --- | --- |
| Size | Fixed size | Dynamic size (can grow or shrink) |
| Data Types | Homogeneous (same type) | Homogeneous and heterogeneous |
| Built-In Methods | Limited | Extensive collection of methods |

### Collection Interfaces:

The Java Collections Framework provides several interfaces to work with collections:

1. ***Collection***: The root interface for all collection types.
2. ***List***: Ordered collection with duplicates allowed (e.g., ArrayList, LinkedList).
3. ***Set***: Unordered collection with no duplicates (e.g., HashSet, TreeSet).
4. ***SortedSet***: Set with sorted elements (e.g., TreeSet).
5. ***NavigableSet***: An extended SortedSet interface.
6. ***Queue***: Represents a queue data structure (e.g., LinkedList, PriorityQueue).
7. ***Map***: Key-value pairs (e.g., HashMap, TreeMap).
8. ***SortedMap***: Map with sorted keys (e.g., TreeMap).
9. ***NavigableMap***: An extended SortedMap interface.

### *Collection Interface*:

- The `Collection` interface is considered the root interface of the Java Collections Framework.
- It defines common methods that are applicable to all types of collections.
- Note that there are no concrete classes that implement the `Collection` interface directly.

### *List Interface*:

- Extends the `Collection` interface.
- Represents an ordered collection where duplicates are allowed.
- Provides methods for indexed access and preserving insertion order.
- Key implementations include `ArrayList`, `LinkedList`, and `Vector`.

### ArrayList:

- Extends the `AbstractList` class and implements the `List` interface.
- Allows duplicates and preserves insertion order.
- *Suitable for holding heterogeneous data, including null values.*
- Can be created with *different initial capacities, and it dynamically resizes.*
- Performance is good for retrieval operations but not ideal for insertions and deletions.

### *How to Get a Synchronized Version of ArrayList:*

To make an `ArrayList` synchronized and thread-safe, you can use the `Collections.synchronizedList()` method. For example:

```java
ArrayList al = new ArrayList();  // This is a non-synchronized ArrayList
List list = Collections.synchronizedList(al); 
// This is a synchronized version
```

### *Functions in ArrayList*

1. **Adding Elements:**
    - `add(E element)`: Add an element to the end of the list.
    - `add(int index, E element)`: Insert an element at the specified index.
2. **Accessing Elements:**
    - `get(int index)`: Get the element at the specified index.
    - `set(int index, E element)`: Set the element at the specified index to a new value.
3. **Removing Elements:**
    - `remove(int index)`: Remove the element at the specified index.
    - `remove(Object o)`: Remove the first occurrence of the specified element.
    - `clear()`: Remove all elements from the list.
4. **Checking for Existence:**
    - `contains(Object o)`: Check if the list contains a specific element.
    - `isEmpty()`: Check if the list is empty.
5. **Size and Capacity:**
    - `size()`: Get the number of elements in the list.
    - `trimToSize()`: Reduce the capacity of the list to the current size.
6. **Searching and Sorting:**
    - `indexOf(Object o)`: Get the index of the first occurrence of the specified element.
    - `lastIndexOf(Object o)`: Get the index of the last occurrence of the specified element.
    - `sort(Comparator<? super E> c)`: Sort the list using a custom comparator.
7. **Bulk Operations:**
    - `addAll(Collection<? extends E> c)`: Add all elements from a collection to the end of the list.
    - `removeAll(Collection<?> c)`: Remove all elements that exist in a given collection.
    - `retainAll(Collection<?> c)`: Retain only the elements that exist in a given collection.
8. **Iterating through Elements:**
    - Using `for-each` loop, iterators, or streams to iterate through the list.
9. **Converting to Arrays:**
    - `toArray()`: Convert the list to an array.
    - `toArray(T[] a)`: Convert the list to an array of a specified type.
10. **Sublist:**
    - `subList(int fromIndex, int toIndex)`: Get a portion of the list as a new list.

### ***LinkedList in Java -class***

LinkedList is a class in Java that implements the List interface and is part of the Java Collections Framework. It is used to create a linked list data structure. Here are some key points and features of LinkedList:

1. **Basic Characteristics:**
    - LinkedList is a child class of the Collection interface.
    - It is present in the `java.util` package.
    - LinkedList preserves the insertion order of elements.
2. **Underlying Data Structure:**
    - The underlying data structure used by LinkedList is a double-linked list.
    - Each element in a LinkedList is represented by a node that contains data and references to the previous and next nodes.
3. **Allowance for Duplicates:**
    - LinkedList allows duplicate elements. You can have the same element multiple times in the list.
4. **Heterogeneous Elements:**
    - LinkedList can hold heterogeneous elements, including different data types like strings and integers.
5. **Null Insertion:**
    - You can insert null elements into a LinkedList.
6. **Interfaces Implemented:**
    - LinkedList implements the Serializable and Cloneable interfaces.
    - It does not implement the RandomAccess interface, meaning it is not efficient for random access operations.
7. **Performance Characteristics:**
    - LinkedList is best suited for scenarios where frequent insertion and deletion of elements in the middle of the list are required.
    - It is less efficient for retrieval operations, as it doesn't provide direct access to elements by index.
8. **Constructor:**
    - You can create a LinkedList using the default constructor or by passing a Collection.

**Constructor Examples:**

```java
LinkedList<E> list = new LinkedList<>();
LinkedList<E> list = new LinkedList<>(Collection<? extends E> c);

```

**LinkedList Operations:**

- LinkedList provides various methods for adding, removing, and accessing elements, similar to other List implementations.

**Example Usage:**

```java
LinkedList<String> linkedList = new LinkedList<>();
linkedList.add("Apple");
linkedList.add("Banana");
linkedList.add("Cherry");

linkedList.addFirst("Mango");
linkedList.addLast("Grapes");

String firstFruit = linkedList.getFirst();
String lastFruit = linkedList.getLast();

linkedList.removeFirst();
linkedList.removeLast();

```

**Difference from ArrayList:**

- ArrayList is more suitable for frequent retrieval operations (random access) and offers better performance in that regard.
- LinkedList is better for frequent insertions and deletions in the middle of the list.

### *Functions in Linked List:*

LinkedList in Java offers a wide range of methods to perform various operations on the linked list data structure. Here are some of the commonly used methods available in the LinkedList class:

***Add Elements:***

1. `add(E e)`: Adds the specified element to the end of the list.
2. `addFirst(E e)`: Inserts the specified element at the beginning of the list.
3. `addLast(E e)`: Appends the specified element to the end of the list.

***Access Elements:***
4. `get(int index)`: Returns the element at the specified position in the list.
5. `getFirst()`: Returns the first element in the list.
6. `getLast()`: Returns the last element in the list.

***Remove Elements:***
7. `remove()`: Removes and returns the first element from the list.
8. `removeFirst()`: Removes and returns the first element from the list.
9. `removeLast()`: Removes and returns the last element from the list.
10. `remove(Object o)`: Removes the first occurrence of the specified element from the list.
11. `remove(int index)`: Removes the element at the specified position in the list.

***Search Elements:***
12. `indexOf(Object o)`: Returns the index of the first occurrence of the specified element in the list.
13. `lastIndexOf(Object o)`: Returns the index of the last occurrence of the specified element in the list.

***Iterate through Elements:***
14. `iterator()`: Returns an iterator over the elements in the list.
15. `listIterator()`: Returns a list iterator over the elements in the list.
16. `descendingIterator()`: Returns an iterator over the elements in reverse sequential order.

***Manipulate List:***
17. `clear()`: Removes all elements from the list.
18. `addAll(Collection<? extends E> c)`: Appends all elements in the specified collection to the end of the list.
19. `addAll(int index, Collection<? extends E> c)`: Inserts all elements in the specified collection into the list at the specified position.
20. `retainAll(Collection<?> c)`: Retains only the elements in the list that are contained in the specified collection.
21. `removeAll(Collection<?> c)`: Removes from the list all elements that are contained in the specified collection.

***Other Operations:***
22. `size()`: Returns the number of elements in the list.
23. `isEmpty()`: Checks if the list is empty.
24. `contains(Object o)`: Checks if the list contains the specified element.
25. `toArray()`: Returns an array containing all the elements in the list.

## *Set Interface:*

In Java, the Set interface is part of the Java Collections Framework and is located in the `java.util` package. It is an interface that extends the Collection interface and represents a collection of elements with no duplicate values. Sets are unordered collections, which means they do not guarantee any specific order of elements. The Set interface does not allow duplicate elements, and it enforces uniqueness.

**Key characteristics of the Set interface in Java:**

1. **No Duplicates:** Sets do not allow duplicate elements. If you try to add a duplicate element to a Set, it won't be added, and the existing element won't be replaced.
2. **Unordered:** Sets do not guarantee any specific order of elements. Elements are not stored in any particular sequence, and there is no index to access elements.
3. **Implements Collection:** The Set interface extends the Collection interface, which means it inherits the methods for adding, removing, checking containment, and other common collection operations.
4. **No Indexing:** Sets do not support indexing or random access like lists (e.g., ArrayList). Elements are accessed through iterators or by converting the Set to an array.

**Common methods provided by the Set interface:**

- `add(E e)`: Adds the specified element to the set if it is not already present.
- `remove(Object o)`: Removes the specified element from the set if it is present.
- `size()`: Returns the number of elements in the set.
- `isEmpty()`: Checks if the set is empty.
- `contains(Object o)`: Checks if the set contains the specified element.
- `clear()`: Removes all elements from the set.
- `iterator()`: Returns an iterator over the elements in the set.
- `toArray()`: Converts the set to an array of elements.

**Common implementations of the Set interface in Java include:**

1. **HashSet:** A commonly used implementation based on a hash table. It provides fast access and insertion of elements. HashSet does not guarantee the order of elements.
2. **LinkedHashSet:** Similar to HashSet but maintains the insertion order of elements. It provides predictable iteration order.
3. **TreeSet:** Implements a sorted set using a Red-Black tree. Elements are stored in ascending order.

Here's a simple example of using a HashSet:

```java
import java.util.HashSet;
import java.util.Set;

public class SetExample {
    public static void main(String[] args) {
        // Create a HashSet of integers
        Set<Integer> set = new HashSet<>();

        // Add elements to the set
        set.add(10);
        set.add(20);
        set.add(30);
        set.add(10); // Duplicate element, won't be added

        // Check if an element exists in the set
        boolean contains = set.contains(20);
        System.out.println("Contains 20: " + contains);

        // Remove an element from the set
        set.remove(30);

        // Print the elements using an iterator
        System.out.print("Elements in the set: ");
        for (int element : set) {
            System.out.print(element + " ");
        }
    }
}

```

## hashset:

A HashSet in Java is an implementation of the Set interface. It is part of the Java Collections Framework and is located in the `java.util` package. HashSet is based on a hash table data structure, which provides fast access, insertion, and removal of elements. It does not guarantee any specific order of elements and does not allow duplicate elements. Here are some key features of HashSet:

1. **Unordered:** HashSet does not maintain the order of elements. The elements are stored in the hash table, and their order is not guaranteed.
2. **No Duplicates:** It enforces uniqueness, meaning it does not allow duplicate elements. If you try to add the same element multiple times, only one instance will be stored.
3. **Fast Operations:** HashSet provides constant-time performance (O(1)) for basic operations like add, remove, and contains, as long as the hash function is well-distributed.
4. **Implements Set Interface:** HashSet implements the Set interface, which means it supports all the methods defined in the Set interface.
5. **Not Synchronized:** HashSet is not synchronized, so it is not thread-safe. If you need a synchronized version, you can use `Collections.synchronizedSet()` to create a synchronized set.
6. **No Null Elements:** HashSet allows one `null` element because of its design. Adding `null` multiple times will result in only one `null` in the set.

Common methods and operations you can perform with a HashSet include:

- `add(E e)`: Adds the specified element to the set if it is not already present.
- `remove(Object o)`: Removes the specified element from the set if it is present.
- `size()`: Returns the number of elements in the set.
- `isEmpty()`: Checks if the set is empty.
- `contains(Object o)`: Checks if the set contains the specified element.
- `clear()`: Removes all elements from the set.
- `iterator()`: Returns an iterator over the elements in the set.
- `toArray()`: Converts the set to an array of elements.

Here's an example of how to use a HashSet:

```java
import java.util.HashSet;
import java.util.Set;

public class HashSetExample {
    public static void main(String[] args) {
        // Create a HashSet of strings
        Set<String> set = new HashSet<>();

        // Add elements to the set
        set.add("apple");
        set.add("banana");
        set.add("cherry");
        set.add("apple"); // Duplicate, won't be added

        // Check if an element exists in the set
        boolean containsBanana = set.contains("banana");
        System.out.println("Contains 'banana': " + containsBanana);

        // Remove an element from the set
        set.remove("cherry");

        // Print the elements using an iterator
        System.out.print("Elements in the set: ");
        for (String element : set) {
            System.out.print(element + " ");
        }
    }
}

```

In this example, we create a HashSet of strings, add elements, check for containment, and remove an element. Note that duplicates are not allowed in the set. The order of elements may vary when you run the code.

Certainly, let's create two separate notes for "Sorted Set" and "TreeSet."

### **Sorted Set:**

 A `SortedSet` is an interface in Java that is part of the Java Collections Framework. It extends the `Set` interface and provides a sorted collection of elements. Key features of `SortedSet` include:

1. **Sorted Elements:** A `SortedSet` stores elements in sorted order. When you iterate over a `SortedSet`, the elements are presented in ascending order by default.
2. **No Duplicates:** Like other sets, `SortedSet` does not allow duplicate elements. If you try to add the same element multiple times, only one instance will be stored.
3. **Navigable:** `SortedSet` extends the `NavigableSet` interface, providing navigation methods such as `ceiling`, `floor`, `higher`, and `lower` for finding elements in the set based on their values.
4. **Comparable or Comparator:** The order of elements in a `SortedSet` can be determined either by the natural order of elements (if they implement the `Comparable` interface) or by using a custom `Comparator` to specify the sorting criteria.
5. **Fast Lookup:** `TreeSet` is a common implementation of `SortedSet` based on a red-black tree, ensuring fast lookup, insertion, and deletion operations with a time complexity of O(log n).
6. **Null Elements:** By default, `TreeSet` does not allow null elements. If you need to store null, you should provide a `Comparator` that allows it.
7. **Not Synchronized:** Like `HashSet`, `TreeSet` is not synchronized. If you need thread-safe access, you can create a synchronized set using `Collections.synchronizedSortedSet()`.

### **TreeSet:**

`TreeSet` is a common implementation of the `SortedSet` interface in Java. Key features of `TreeSet` include:

1. **Sorted Collection:** `TreeSet` maintains elements in sorted order. Elements are stored in ascending order by default.
2. **No Duplicates:** Duplicate elements are not allowed in a `TreeSet`. If you attempt to add duplicates, only one instance is stored.
3. **Navigable Operations:** It provides various navigable operations such as `ceiling`, `floor`, `higher`, and `lower` for finding elements based on their values.
4. **Custom Sorting:** You can define custom sorting criteria using a `Comparator` when creating a `TreeSet`. This allows you to sort elements in a specific order.
5. **Fast Lookup:** `TreeSet` is based on a red-black tree data structure, ensuring fast lookup, insertion, and deletion operations with a time complexity of O(log n).
6. **No Nulls by Default:** By default, `TreeSet` does not allow null elements. You can store null elements by providing a custom `Comparator` that allows them.
7. **Thread Safety:** `TreeSet` is not thread-safe. If you need thread-safe access to a `TreeSet`, you can create a synchronized set using `Collections.synchronizedSortedSet()`.

In summary, `TreeSet` is a widely used implementation of the `SortedSet` interface in Java, offering sorted and navigable collections that are useful for maintaining data in a specific order and performing efficient lookups.

### Differences between Set Interface implemented Classes:

| Aspect | HashSet | LinkedHashSet | TreeSet |
| --- | --- | --- | --- |
| Underlying Data Structure | Hash table (hash map) | Hash table with linked list | Red-black tree (binary search tree) |
| Order of Elements | Unordered | Maintains insertion order | Sorted in ascending/natural order |
| Duplicates | Not allowed | Not allowed | Not allowed |
| Null Elements | Allows one null element | Allows one null element | Not allowed |
| Performance | O(1) for average-case operations, may degrade with hash collisions | Slightly slower due to maintaining order | O(log n) for average-case operations |
| Use Cases | Efficient for lookup operations, no order requirement | Maintains insertion order, no duplicates | Sorted collection, ordered elements |
| Iterating Order | Unpredictable | Follows insertion order | Follows sorting order |

## *Map Interface in java:*

The `Map` interface in Java is a part of the Java Collections Framework and is used to represent a collection of key-value pairs. It does not extend the `Collection` interface but plays a crucial role in associating values with keys for efficient retrieval. A `Map` does not allow duplicate keys and each key can map to at most one value. The primary implementations of the `Map` interface are `HashMap`, `TreeMap`, and `LinkedHashMap`.

Here are some key points and methods associated with the `Map` interface:

**Key Characteristics:**

1. A `Map` stores key-value pairs.
2. Keys are unique within a `Map`, meaning each key can map to only one value.
3. It does not extend the `Collection` interface.

**Methods:**

1. `put(K key, V value)`: Associates the specified value with the specified key in the map.
2. `get(Object key)`: Returns the value to which the specified key is mapped.
3. `remove(Object key)`: Removes the key-value pair associated with the specified key.
4. `containsKey(Object key)`: Checks if the map contains a mapping for the specified key.
5. `containsValue(Object value)`: Checks if the map contains one or more keys for the specified value.
6. `keySet()`: Returns a set view of the keys contained in the map.
7. `values()`: Returns a collection view of the values contained in the map.
8. `entrySet()`: Returns a set view of the key-value mappings contained in the map.

**Implementations:**

1. `HashMap`: Provides fast and efficient lookups based on the hash code of the keys. It does not guarantee any specific order of key-value pairs.
2. `TreeMap`: Maintains the keys in a sorted order. It is based on a Red-Black Tree data structure.
3. `LinkedHashMap`: Maintains the order of insertion. It provides predictable iteration order and is slightly slower than `HashMap`.

Here's an example of how to use the `Map` interface in Java:

```java
import java.util.HashMap;
import java.util.Map;

public class MapExample {
    public static void main(String[] args) {
        // Create a Map
        Map<String, Integer> scores = new HashMap<>();

        // Add key-value pairs
        scores.put("Alice", 95);
        scores.put("Bob", 87);
        scores.put("Charlie", 92);

        // Access values by key
        int aliceScore = scores.get("Alice");
        System.out.println("Alice's score: " + aliceScore);

        // Check if a key exists
        boolean containsKey = scores.containsKey("David");
        System.out.println("Contains key 'David': " + containsKey);

        // Iterate through key-value pairs
        for (Map.Entry<String, Integer> entry : scores.entrySet()) {
            System.out.println("Name: " + entry.getKey() + 
", Score: " + entry.getValue());
        }
    }
}

```

In this example, we create a `HashMap` to store scores for different people. We add key-value pairs, retrieve values by keys, and iterate through the entries in the map.

### Hashmap:

`HashMap` is one of the most commonly used implementations of the `Map` interface in Java. It is part of the Java Collections Framework and is used to store key-value pairs in a non-sorted, unordered manner. `HashMap` provides efficient key-value retrieval and is widely used in various applications.

Here are some key characteristics and usage of `HashMap` in Java:

**Key Characteristics:**

1. Stores key-value pairs.
2. Keys are unique within a `HashMap`, meaning each key can map to only one value.
3. Does not maintain the order of key-value pairs.
4. Provides constant-time average complexity for basic operations like `get()` and `put()`.

**Key Methods:**

1. `put(K key, V value)`: Associates the specified value with the specified key in the `HashMap`.
2. `get(Object key)`: Returns the value to which the specified key is mapped, or `null` if the key is not found.
3. `remove(Object key)`: Removes the key-value pair associated with the specified key.
4. `containsKey(Object key)`: Checks if the `HashMap` contains a mapping for the specified key.
5. `containsValue(Object value)`: Checks if the `HashMap` contains one or more keys for the specified value.
6. `keySet()`: Returns a set view of the keys contained in the `HashMap`.
7. `values()`: Returns a collection view of the values contained in the `HashMap`.
8. `entrySet()`: Returns a set view of the key-value mappings contained in the `HashMap`.

**Example of Using `HashMap`:**

```java
import java.util.HashMap;
import java.util.Map;

public class HashMapExample {
    public static void main(String[] args) {
        // Create a HashMap
        Map<String, Integer> scores = new HashMap<>();

        // Add key-value pairs
        scores.put("Alice", 95);
        scores.put("Bob", 87);
        scores.put("Charlie", 92);

        // Access values by key
        int aliceScore = scores.get("Alice");
        System.out.println("Alice's score: " + aliceScore);

        // Check if a key exists
        boolean containsKey = scores.containsKey("David");
        System.out.println("Contains key 'David': " + containsKey);

        // Iterate through key-value pairs
        for (Map.Entry<String, Integer> entry : scores.entrySet()) {
            System.out.println("Name: " + entry.getKey() + ", Score: " + entry.getValue());
        }
    }
}

```

In the example, we create a `HashMap` to store scores for different people. We add key-value pairs, retrieve values by keys, and iterate through the entries in the `HashMap`.

`HashMap` is widely used for tasks that require efficient key-value lookups and do not require a specific order of elements. However, it does not guarantee the order of key-value pairs, and if order preservation is needed, other implementations like `LinkedHashMap` or `TreeMap` should be considered.

### Linked Hash Map:

`LinkedHashMap` is another implementation of the `Map` interface in Java, which is similar to a `HashMap` with an additional feature: it maintains the order of key-value pairs based on the order in which they were added to the map. It is part of the Java Collections Framework and is often used when you need to iterate through the elements in a specific order.

Here are some key characteristics and usage of `LinkedHashMap` in Java:

**Key Characteristics:**

1. Stores key-value pairs.
2. Keys are unique within a `LinkedHashMap`.
3. Maintains the order of key-value pairs based on insertion order.
4. Provides constant-time average complexity for basic operations like `get()` and `put()`.

**Key Methods:**

1. `put(K key, V value)`: Associates the specified value with the specified key in the `LinkedHashMap`.
2. `get(Object key)`: Returns the value to which the specified key is mapped, or `null` if the key is not found.
3. `remove(Object key)`: Removes the key-value pair associated with the specified key.
4. `containsKey(Object key)`: Checks if the `LinkedHashMap` contains a mapping for the specified key.
5. `containsValue(Object value)`: Checks if the `LinkedHashMap` contains one or more keys for the specified value.
6. `keySet()`: Returns a set view of the keys contained in the `LinkedHashMap`. The order is based on insertion order.
7. `values()`: Returns a collection view of the values contained in the `LinkedHashMap`. The order matches the key order.
8. `entrySet()`: Returns a set view of the key-value mappings contained in the `LinkedHashMap`. The order is based on insertion order.

**Example of Using `LinkedHashMap`:**

```java
import java.util.LinkedHashMap;
import java.util.Map;

public class LinkedHashMapExample {
    public static void main(String[] args) {
        // Create a LinkedHashMap
        Map<String, Integer> scores = new LinkedHashMap<>();

        // Add key-value pairs
        scores.put("Alice", 95);
        scores.put("Bob", 87);
        scores.put("Charlie", 92);

        // Access values by key
        int aliceScore = scores.get("Alice");
        System.out.println("Alice's score: " + aliceScore);

        // Check if a key exists
        boolean containsKey = scores.containsKey("David");
        System.out.println("Contains key 'David': " + containsKey);

        // Iterate through key-value pairs (maintains insertion order)
        for (Map.Entry<String, Integer> entry : scores.entrySet()) {
            System.out.println("Name: " + entry.getKey() + ", Score: " + entry.getValue());
        }
    }
}

```

In the example, we create a `LinkedHashMap` to store scores for different people. We add key-value pairs, retrieve values by keys, and iterate through the entries in the `LinkedHashMap`. Unlike a regular `HashMap`, `LinkedHashMap` maintains the order of key-value pairs based on insertion order.

`LinkedHashMap` is useful when you need predictable order, such as iterating through elements in the order they were added. However, it may have a slightly higher memory overhead compared to a regular `HashMap`.

### TreeMap:

`TreeMap` is an implementation of the `Map` interface in Java that stores key-value pairs in a sorted order based on the keys. It is part of the Java Collections Framework and is backed by a Red-Black Tree, which allows for efficient insertion, deletion, and retrieval operations. `TreeMap` is commonly used when you need to maintain a sorted order of elements based on their keys.

Here are some key characteristics and usage of `TreeMap` in Java:

**Key Characteristics:**

1. Stores key-value pairs.
2. Keys are unique within a `TreeMap`.
3. Maintains elements in a sorted order based on the keys.
4. Provides O(log N) time complexity for most operations, making it suitable for large datasets.

**Key Methods:**

1. `put(K key, V value)`: Associates the specified value with the specified key in the `TreeMap`.
2. `get(Object key)`: Returns the value to which the specified key is mapped or `null` if the key is not found.
3. `remove(Object key)`: Removes the key-value pair associated with the specified key.
4. `containsKey(Object key)`: Checks if the `TreeMap` contains a mapping for the specified key.
5. `keySet()`: Returns a set view of the keys contained in the `TreeMap`, sorted in ascending order.
6. `values()`: Returns a collection view of the values contained in the `TreeMap`. The order corresponds to the sorted key order.
7. `entrySet()`: Returns a set view of the key-value mappings contained in the `TreeMap`. The order is based on the sorted key order.

**Example of Using `TreeMap`:**

```java
import java.util.TreeMap;
import java.util.Map;

public class TreeMapExample {
    public static void main(String[] args) {
        // Create a TreeMap
        Map<String, Integer> population = new TreeMap<>();

        // Add key-value pairs
        population.put("New York", 8400000);
        population.put("Los Angeles", 3990000);
        population.put("Chicago", 2716000);

        // Access values by key
        int nyPopulation = population.get("New York");
        System.out.println("Population of New York: " + nyPopulation);

        // Check if a key exists
        boolean containsKey = population.containsKey("Houston");
        System.out.println("Contains key 'Houston': " + containsKey);

        // Iterate through key-value pairs (sorted by key)
        for (Map.Entry<String, Integer> entry : population.entrySet()) {
            System.out.println("City: " + entry.getKey() + ", Population: " + entry.getValue());
        }
    }
}

```

In the example, we create a `TreeMap` to store population data for different cities. We add key-value pairs, retrieve values by keys, and iterate through the entries in the `TreeMap`. `TreeMap` ensures that the elements are maintained in a sorted order based on the keys.

`TreeMap` is useful when you need to access elements in a sorted order, such as iterating through elements by key order. However, it may have a slightly higher memory overhead compared to other map implementations.

### camparable and comparator:

In Java, both `Comparable` and `Comparator` are interfaces that allow you to define custom sorting orders for objects. They are essential when you need to sort collections of objects based on specific criteria. However, they serve slightly different purposes:

**1. Comparable:**
The `Comparable` interface is used to provide a natural ordering for a class. When a class implements the `Comparable` interface, it defines a default way of comparing its instances. This default comparison is used when you call sorting methods, such as `Collections.sort()` or `Arrays.sort()`. The natural order is based on the class's inherent characteristics.

To implement the `Comparable` interface, a class must override the `compareTo` method, which compares the current object with another object and returns a negative integer if it is less than the other object, zero if they are equal, and a positive integer if it is greater.

Here's an example of a `Comparable` implementation for a `Person` class:

```java
public class Person implements Comparable<Person> {
    private String name;
    private int age;

    // Constructor, getters, setters, etc.

    @Override
    public int compareTo(Person otherPerson) {
        // Compare based on age
        return this.age - otherPerson.age;
    }
}

```

You can then sort a collection of `Person` objects using `Collections.sort()`:

```java
List<Person> people = new ArrayList<>();
// Add Person objects to the list
Collections.sort(people); // Sort based on age (natural order)

```

**2. Comparator:**
The `Comparator` interface is used to provide custom sorting orders for classes that you cannot modify, and it allows you to define multiple comparison strategies for a class. You can create separate `Comparator` objects to specify different sorting criteria without altering the class's source code.

To use a `Comparator`, you create a separate class that implements the `Comparator` interface and overrides the `compare` method. This method compares two objects according to the desired criteria. You can then use the `Comparator` with sorting methods like `Collections.sort()` or provide it as an argument when needed.

Here's an example of a `Comparator` implementation for the `Person` class to sort people by their names:

```java
public class NameComparator implements Comparator<Person> {
    @Override
    public int compare(Person person1, Person person2) {
        return person1.getName().compareTo(person2.getName());
    }
}

```

You can sort a collection of `Person` objects by name using the `NameComparator`:

```java
List<Person> people = new ArrayList<>();
// Add Person objects to the list
Collections.sort(people, new NameComparator()); // Sort based on name

```

In summary, the `Comparable` interface is used to define a natural order for a class, while the `Comparator` interface allows you to create custom sorting strategies for a class or use multiple sorting criteria without modifying the class itself. You choose between them based on whether you have control over the class's source code and whether you need to define custom sorting for the class.

**comparison between `HashMap`, `LinkedHashMap`, `TreeMap`, and `Hashtable`**

| Characteristic | HashMap | LinkedHashMap | TreeMap | Hashtable |
| --- | --- | --- | --- | --- |
| Class Hierarchy | HashMap is part of the Java Collections Framework and extends the AbstractMap class. | LinkedHashMap is also part of the Java Collections Framework and extends HashMap. | TreeMap is part of the Java Collections Framework and implements the NavigableMap interface. | Hashtable is part of the Java Collections Framework and extends the Dictionary class. |
| Iteration Order | Does not guarantee any specific order of elements. | Maintains insertion order, allowing predictable iteration order. | Orders elements based on their natural order or a custom Comparator. | Does not guarantee any specific order of elements. |
| Allows Null Values | Allows one null key and multiple null values. | Allows one null key and multiple null values. | Does not allow null keys but allows multiple null values. | Does not allow null keys or null values. |
| Thread Safety | Not thread-safe by default. | Not thread-safe by default. | Not thread-safe by default. | Thread-safe, but performance may be affected due to synchronization. |
| Performance (Insertion/Deletion/Search) | Offers good performance for insertion, deletion, and searching. | Offers good performance for insertion, deletion, and searching. | Provides O(log n) time complexity for insertion, deletion, and searching. | Offers good performance for insertion, deletion, and searching. |
| Use Cases | Suitable for most general use cases. | Suitable when you need to maintain insertion order. | Suitable when elements should be ordered (e.g., sorting by keys). | Legacy class; use HashMap for new code, as it's more efficient and versatile. |
| Overhead | Lower overhead than LinkedHashMap and TreeMap. | Slightly higher overhead due to maintaining order. | Slightly higher overhead due to tree structure. | Slightly higher overhead due to synchronization. |
| Keys and Values | Keys may be unique, and values may be duplicate. | Keys may be unique, and values may be duplicate. | Keys may be unique, and values may be duplicate. | Keys must be unique, and values may be duplicate. |

### Internal workings of `HashMap` and `HashSet`

**HashMap**

**Step 1: Hashing**

When you add a key-value pair to a `HashMap`, it first calculates a hash code for the key. This hash code is calculated using the `hashCode` method of the key object.

**Step 2: Finding the Bucket**

The hash code is used to find a bucket within the `HashMap`. The hash code is divided by the total number of buckets, and the remainder determines which bucket to use. For example, if the hash code is 42, and there are 16 buckets, it will go into bucket `42 % 16 = 10`.

**Step 3: Handling Collisions**

Sometimes, different keys might have the same hash code (hash code collision). To handle this, `HashMap` uses a linked list to store multiple key-value pairs in the same bucket.

**Step 4: Storing Key-Value Pair**

The key-value pair is stored in the linked list in the selected bucket. The key is used to determine if the key is already present in the list. If it is, the `HashMap` will update the value; if not, it will add a new node to the linked list.

**Step 5: Retrieval**

When you want to retrieve a value associated with a key, `HashMap` calculates the hash code for the key again, finds the bucket, and scans the linked list in that bucket to find the matching key. This process is very efficient, even with a large number of elements, thanks to the hash code and bucket structure.

Example:

```java
HashMap<String, Integer> fruitPrices = new HashMap<>();
fruitPrices.put("apple", 2);
fruitPrices.put("banana", 1);
fruitPrices.put("cherry", 3);

int price = fruitPrices.get("banana"); // Retrieving the price of a banana
System.out.println("Price of banana: " + price);

```

---

**HashSet**

`HashSet` is built on top of `HashMap` and is used to store a collection of unique elements.

**Step 1: Hashing**

When you add an element to a `HashSet`, it calculates a hash code for the element in the same way `HashMap` does.

**Step 2: Leveraging `HashMap`**

`HashSet` uses a `HashMap` under the hood. It treats the element you add as both the key and a dummy value in the `HashMap`. This is because `HashMap` only allows unique keys.

**Step 3: Storing Unique Elements**

When you add an element to the `HashSet`, it is added to the `HashMap` as a key. The `HashMap` ensures that only unique keys are allowed. If you try to add the same element again, it won't be added, ensuring that `HashSet` contains only unique elements.

Example:

```java
HashSet<String> uniqueFruits = new HashSet<>();
uniqueFruits.add("apple");
uniqueFruits.add("banana");
uniqueFruits.add("cherry");

// Adding the same element won't change the set
uniqueFruits.add("banana");

System.out.println("Unique fruits: " + uniqueFruits);

```

In the example, `"banana"` is added to the `HashSet` only once, even if you attempt to add it again. This ensures that the `HashSet` contains only unique elements, and it leverages `HashMap` for this purpose.

In summary, both `HashMap` and `HashSet` use the concept of hashing to efficiently store and retrieve elements. `HashMap` uses key-value pairs, while `HashSet` uses a simplified version with keys only to enforce uniqueness. Under the hood, `HashSet` uses a `HashMap` to ensure the uniqueness of elements.

# 5.*Sql Queries:*

### *1. Basic Queries:*

| Query | Description |
| --- | --- |
| SELECT * FROM table_name; | Retrieve all records from a table. |
| SELECT column1, column2 FROM table_name; | Retrieve specific columns from a table. |
| SELECT DISTINCT column_name FROM table_name; | Retrieve distinct values from a column. |
| SELECT * FROM table_name WHERE condition; | Filter records based on a condition. |
| SELECT * FROM table_name ORDER BY column_name ASC; | Sort records in ascending order. |
| SELECT * FROM table_name ORDER BY column_name DESC; | Sort records in descending order. |

### *2. Advanced Queries:*

| Query | Description |
| --- | --- |
| SELECT * FROM table_name WHERE column_name IS NULL; | Retrieve records with NULL values in a column. |
| SELECT * FROM table_name WHERE column_name BETWEEN value1 AND value2; | Retrieve records between a specific range of values. |
| SELECT COUNT(*) FROM table_name; | Count the number of records in a table. |
| SELECT AVG(column_name) FROM table_name; | Calculate the average of a column. |
| SELECT SUM(column_name) FROM table_name; | Calculate the sum of a column. |

### *3. Conditional Queries:*

| Query | Description |
| --- | --- |
| SELECT MIN(column_name) FROM table_name; | Find the minimum value in a column. |
| SELECT MAX(column_name) FROM table_name; | Find the maximum value in a column. |
| SELECT * FROM table_name WHERE condition1 AND condition2; | Retrieve records based on multiple conditions using AND. |
| SELECT * FROM table_name WHERE condition1 OR condition2; | Retrieve records based on multiple conditions using OR. |
| SELECT * FROM table_name WHERE column_name LIKE 'pattern'; | Retrieve records that match a specific pattern using LIKE. |

### *4. Join Queries:*

| Query | Description |
| --- | --- |
| SELECT * FROM table1 JOIN table2 ON table1.column = table2.column; | Join two tables based on a common column. |
| SELECT * FROM table1 WHERE column NOT IN (SELECT column FROM table2); | Retrieve records from one table that have no matching records in another table. |
| SELECT * FROM table1 JOIN table2 ON table1.column = table2.column; | Retrieve records from two tables with a one-to-many relationship. |
| SELECT * FROM table1 JOIN junction_table ON table1.column = junction_table.column JOIN table2 ON junction_table.column = table2.column; | Retrieve records from two tables with a many-to-many relationship. |

### *5. Subqueries:*

| Query | Description |
| --- | --- |
| SELECT * FROM table1 INTERSECT SELECT * FROM table2; | Retrieve records that are present in both tables. |
| SELECT * FROM table_name WHERE column IN (SELECT column FROM subquery); | Retrieve records from a table using a subquery. |

### *7. Data Manipulation:*

| Query | Description |
| --- | --- |
| UPDATE table_name SET column = value WHERE condition; | Update records in a table based on a condition. |
| DELETE FROM table_name WHERE condition; | Delete records from a table based on a condition. |
| INSERT INTO table_name (column1, column2) VALUES (value1, value2); | Insert records into a table. |
| INSERT INTO table1 (column1, column2) SELECT column1, column2 FROM table2; | Insert records into a table with values from another table. |

### *8. Table Manipulation:*

| Query | Description |
| --- | --- |
| CREATE TABLE table_name (column1 datatype, column2 datatype, ...); | Create a new table with specific columns. |
| ALTER TABLE table_name ADD column_name datatype; | Add a new column to an existing table. |
| ALTER TABLE table_name MODIFY column_name new_datatype; | Modify the structure of a table. |
| DROP TABLE table_name; | Delete a table from the database. |

### *9. Miscellaneous Queries:*

| Query | Description |
| --- | --- |
| SELECT * FROM table_name LIMIT N; | Retrieve the top N records from a table. |
| SELECT column_name FROM table_name ORDER BY column_name DESC LIMIT N-1, 1; | Retrieve the Nth highest value from a column. |
| SELECT product_name, SUM(sales) FROM sales_table GROUP BY product_name; | Calculate the total sales for each product. |
| SELECT department, AVG(salary) FROM employee_table GROUP BY department; | Calculate the average salary by department. |
| SELECT column, COUNT(*) FROM table_name GROUP BY column HAVING COUNT(*) > 1; | Find duplicate records in a table. |
| SELECT * FROM table_name WHERE column_name IN (value1, value2, ...); | Retrieve records based on multiple conditions using IN. |
| SELECT * FROM table_name WHERE column_name BETWEEN value1 AND value2; | Retrieve records based on a condition using BETWEEN. |
| SELECT MONTH(date_column), SUM(revenue) FROM sales_table GROUP BY MONTH(date_column); | Calculate the total revenue for each month. |
| SELECT * FROM table_name ORDER BY date_column DESC; | Retrieve the most recent records from a table. |

---

# Spring Boot Annotations:

| Annotation Name | Description | Example |
| --- | --- | --- |
| @SpringBootApplication | Main annotation for the Spring Boot application. It enables component scanning and auto-configuration. | java @SpringBootApplication public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } |
| @Controller | Indicates that a class is a Spring MVC controller. | java @Controller public class MyController { // Controller methods go here } |
| @RestController | Combines @Controller and @ResponseBody. Used for RESTful web services. | java @RestController public class MyRestController { // REST controller methods go here } |
| @RequestMapping | Maps HTTP requests to handler methods. | java @RequestMapping("/api") public class MyController { // Request mapping methods go here } |
| @GetMapping | Handles HTTP GET requests. | java @GetMapping("/resource") public String getResource() { return "Resource Data"; } |
| @PostMapping | Handles HTTP POST requests. | java @PostMapping("/create") public String createResource(@RequestBody Resource resource) { return "Resource Created"; } |
| @PutMapping | Handles HTTP PUT requests. | java @PutMapping("/update/{id}") public String updateResource(@PathVariable Long id, @RequestBody Resource resource) { return "Resource Updated"; } |
| @DeleteMapping | Handles HTTP DELETE requests. | java @DeleteMapping("/delete/{id}") public String deleteResource(@PathVariable Long id) { return "Resource Deleted"; } |
| @Autowired | Injects dependencies into a Spring Bean. | java @Service public class MyService { @Autowired private MyRepository repository; } |
| @Component | Indicates that a class is a Spring component (usually used for auto-discovery). | java @Component public class MyComponent { // Component logic here } |
| @Repository | Indicates that a class is a Spring Data repository. | java @Repository public interface MyRepository extends JpaRepository<MyEntity, Long> { // Repository methods here } |
| @Service | Indicates that a class is a service. | java @Service public class MyService { // Service methods here } |
| @Configuration | Indicates that a class declares Spring Beans. | java @Configuration public class MyConfig { @Bean public MyBean myBean() { return new MyBean(); } } |
| @Value | Injects values from application.properties into a Spring Bean. | java @Service public class MyService { @Value("${my.property}") private String property; } |
| @Profile | Defines profiles for a Spring Bean. | java @Service @Profile("dev") public class DevService { // Dev profile service logic } |
| @EnableAutoConfiguration | Automatically configures Spring Boot application. | java @SpringBootApplication @EnableAutoConfiguration public class MyApplication { // Application configuration here } |
| @ConditionalOnProperty | Conditional bean creation based on property values. | java @Service @ConditionalOnProperty(name = "feature.enabled", havingValue = "true") public class FeatureService { // Feature logic here } |
| @ConditionalOnClass | Conditional bean creation based on the presence of specific classes. | java @Configuration @ConditionalOnClass(name = "org.springframework.data.jpa.repository.JpaRepository") public class JpaConfig { // JPA configuration here } |
| @EnableCaching | Enables Spring's caching capabilities. | java @SpringBootApplication @EnableCaching public class MyApplication { // Caching configuration here } |
| @Transactional | Marks a method for transaction management. | java @Service public class MyService { @Transactional public void performTransaction() { // Transactional logic here } } |

# Java Interviews Questions:

### Q1: Does Abstract class have constructor?

 Yes, an abstract class can have a constructor. Abstract classes can have both abstract and concrete (implemented) methods, and they may need constructors to initialize their internal state.

### Q2. Difference between abstract class and
interface?

| Aspect | Abstract Class | Interface |
| --- | --- | --- |
| Inheritance | Supports single class inheritance. | Supports multiple interface inheritance. |
| Constructors | Can have constructors. | Cannot have constructors. |
| Fields | Can have instance variables. | Fields are implicitly public, static, and final. |
| Methods | Can have both abstract and concrete methods. | Contains only abstract methods (prior to Java 8). |
| Default Methods (Java 8+) | Can provide method implementations. | Can provide default method implementations. |
| Access Modifiers | Can have different access modifiers (public, protected, private, etc.). | Methods are implicitly public. |
| Purpose | Used for code sharing among related classes. | Used to achieve multiple inheritance of type. |
| Usage | Define a common base class for subclasses. | Define a contract for classes to implement. |
| Relationships | Depicts an "is-a" relationship between the abstract class and its subclasses. | Depicts a "can-do" relationship between implementing classes and the interface. |
| Extending Multiple | Cannot extend multiple abstract classes. | A class can implement multiple interfaces. |
| Flexibility | Provides more flexibility in evolving the class hierarchy. | Provides greater flexibility in reusing code across different class hierarchies. |

### Q3: Why Java 8 has introduced default methods?

Java 8 introduced default methods in interfaces to provide a way to add new methods to interfaces without breaking backward compatibility with existing classes that implement those interfaces.

### Q4: Why Java 8 has introduced static methods?

Java 8 introduced static methods in interfaces to allow interfaces to have utility methods without the need for an implementing class. This simplifies code organization and promotes better encapsulation.

### Q5: Why Java does not allow multiple inheritance?

Java does not allow multiple inheritance of classes to avoid the "diamond problem," where ambiguity arises when a class inherits from multiple classes with the same method name. It allows multiple inheritance through interfaces to achieve multiple inheritance of type safely.

### **Q6: What are the rules for Method Overloading and Method Overriding?**

- Method Overloading:
    - Method overloading occurs within a single class.
    - Methods must have the same name but different parameter lists (number or type of parameters).
    - Return type may or may not be the same.
- Method Overriding:
    - Method overriding occurs in a superclass-subclass relationship.
    - Overriding methods must have the same method signature (name, parameters, and return type).
    - The subclass method cannot reduce the visibility of the superclass method (e.g., you can't override a public method with a private method).

### **Q7: Can constructors and private methods be overridden?**

Constructors cannot be overridden as they are not inherited by subclasses. Private methods in Java are implicitly final, which means they cannot be overridden by subclasses.

### **Q8: Difference between error and exception**

- Errors are severe issues that are typically not recoverable, such as "Out of Memory" errors. Exceptions, on the other hand, are issues that can be handled and are meant to allow the program to continue its execution.

### Q9**: What are the different types of exceptions?**

- In Java, exceptions are categorized into two main types:
    1. **Checked Exceptions:** These are exceptions that are checked at compile-time and are meant to be handled by the programmer. Examples include **`IOException`** and **`SQLException`**.
    2. **Unchecked Exceptions:** These are exceptions that are not checked at compile-time and typically indicate programming errors or unexpected conditions. Examples include **`NullPointerException`** and **`ArrayIndexOutOfBoundsException`**.
    

### **Q10: How is exception handling done in Java?**

- Exception handling in Java is done using the **`try`**, **`catch`**, **`finally`**, and **`throw`** statements. Code that might throw an exception is placed within a **`try`** block. If an exception occurs, it is caught and handled in one or more **`catch`** blocks. The **`finally`** block is used for cleanup code that must be executed regardless of whether an exception occurred.

### Q**11: Can we write a try block without a catch block?**

- Yes, you can write a try block without a catch block, but it must be followed by either a catch block or a finally block. The catch block handles exceptions, while the finally block is used for cleanup.

### **Q12: How to handle multiple exceptions together?**

- You can handle multiple exceptions together by using multiple catch blocks, each designed to catch a specific type of exception. The catch blocks are evaluated in order, and the first one that matches the exception type is executed.

### **Q13: When will the finally block not get executed?**

- The **`finally`** block will not get executed if the program exits due to a system exit (e.g., **`System.exit(0)`**) or if an unrecoverable error occurs in the JVM.

### **Q14: Difference between the throw and throws keywords, and discuss Exception Propagation**

- The **`throw`** keyword is used to explicitly throw an exception from a method or block of code. The **`throws`** keyword is used in a method declaration to indicate that the method can throw exceptions and specifies the exception types it might throw.Exception propagation refers to how exceptions are passed from a method to its caller. If a method throws a checked exception, it must declare it using the **`throws`** keyword. The caller of that method can either handle the exception using a try-catch block or propagate it by declaring it again using the **`throws`** keyword.

### **Q15: Exception handling with respect to method overriding**

- When a subclass overrides a superclass method, it must adhere to the method's declared exceptions in the superclass. It can add more specific exceptions but cannot throw broader exceptions.

### **Q16: How to make your own custom exception class?**

- To create a custom exception class in Java, you should extend the **`Exception`** class or one of its subclasses, such as **`RuntimeException`**. For example:

```java
javaCopy code
public class CustomException extends Exception {
    public CustomException(String message) {
        super(message);
    }
}
```

### **Q17: How to make custom checked and unchecked exceptions?**

- To create a custom checked exception, extend the **`Exception`** class. For unchecked exceptions, extend the **`RuntimeException`** class. Customize your exception class as needed.

### **Q18: What happens when you throw an exception from the finally block?**

- If an exception is thrown from a **`finally`** block, it will override any other exception being thrown or caught within the **`try`** or **`catch`** blocks, and the new exception will be propagated.

### ***Q19: What will be the output of a program related to try-catch-finally?***

- To determine the output of a specific program, you would need to provide the program's code.

### ***Q20: Explain try-with-resources***

- The try-with-resources statement is used for automatic resource management, such as closing a file or a database connection when you're done with it. It simplifies resource handling by automatically closing resources at the end of the block, reducing the risk of resource leaks.

**Q21: Why is String Immutable?**

- Strings are immutable in Java for several reasons, including security, synchronization, and performance optimization. Immutable strings cannot be modified once created, making them safe for use in various contexts.

**Q22: What does the equals() method of the String class do?**

- The **`equals()`** method of the String class is used to compare the contents (character sequences) of two strings. It returns **`true`** if the strings have the same characters in the same order, and **`false`** otherwise.

**Q23: Explain StringBuffer and StringBuilder**

- Both **`StringBuffer`** and **`StringBuilder`** are used for string manipulation. The key difference is that **`StringBuffer`** is synchronized (thread-safe), making it suitable for use in multithreaded environments. In contrast, **`StringBuilder`** is not synchronized, providing better performance in single-threaded scenarios.

**Q24: Explain the output of a program related to the equals() method of StringBuilder**

- To explain the output of a specific program, you would need to provide the code of that program.

**Q25: When to use String/StringBuffer/StringBuilder**

- Use **`String`** when the content is fixed and should not change, use **`StringBuffer`** when thread safety is required, and use **`StringBuilder`** when you need better performance in a single-threaded environment.

**Q26: Explain equals and hashcode contract**

- The "equals and hashcode contract" states that if two objects are equal according to the **`equals`** method, they must have the same hash code. Violating this contract can lead to issues when storing objects in hash-based collections like **`HashMap`**.

**Q27: What is a Marker Interface?**

- A marker interface is an interface with no methods. It serves as a marker to inform the compiler or runtime environment about the capabilities or behavior of classes that implement it. Examples include the **`Serializable`** and **`Cloneable`** interfaces.

**Q28: Can you write your own custom Marker interface?**

- Yes, you can create your own marker interface by defining an interface without any methods. Classes that implement your custom marker interface can be identified by the marker.

**Q29: What is Comparable and Comparator?**

- **`Comparable`** is an interface used to define the natural order of objects, allowing them to be compared and sorted based on their inherent attributes. **`Comparator`** is an interface used to define custom comparison rules for objects. It's useful when you want to compare objects in ways other than their natural order.

**Q30: How to compare a list of Employees based on name and age, sorting by name and, if names are the same, by age**

- You can create a custom **`Comparator`** to achieve this sorting logic. Here's an example:

```java
import java.util.Comparator;

class Employee {
    String name;
    int age;

    public Employee(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

public class EmployeeComparator implements Comparator<Employee> {
    @Override
    public int compare(Employee emp1, Employee emp2) {
        int nameComparison = emp1.name.compareTo(emp2.name);
        if (nameComparison != 0) {
            return nameComparison; // Compare by name
        }
        return Integer.compare(emp1.age, emp2.age); // If names are the same, compare by age
    }
}

```

**Question 39: Difference between Comparable and Comparator**

- **`Comparable`** is an interface that defines a natural ordering of objects. It's implemented by the class of the objects you want to compare. **`Comparator`** is an interface that allows you to define custom comparison logic for objects and is implemented in a separate class.

**Question 40: Different methods of Object class**

- The **`Object`** class in Java provides several methods that are inherited by all other classes. Some of the important methods include **`equals()`**, **`hashCode()`**, **`toString()`**, **`getClass()`**, **`clone()`**, **`finalize()`**, **`notify()`**, and **`wait()`**.

**Question 41: What type of arguments are allowed in System.out.println() method?**

- The **`System.out.println()`** method accepts arguments of various data types, including **`String`**, numeric types (int, double, float, etc.), and other objects. The method converts these arguments to their string representations and prints them to the console.

**Question 42: Explain the System.out.println() statement**

- **`System.out.println()`** is a Java statement that prints the string representation of the provided argument(s) to the standard output (usually the console). It appends a newline character after printing the argument(s).

**Question 43: Explain Auto-boxing and Unboxing**

- Auto-boxing is the automatic conversion of primitive data types into their corresponding wrapper classes (e.g., **`int`** to **`Integer`**) when required. Unboxing is the reverse process, where the wrapper class is automatically converted back to the primitive data